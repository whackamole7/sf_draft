const b=o=>(t,i,r)=>{const l=r.subscribe;return r.subscribe=(h,d,u)=>{let c=h;if(d){const m=(u==null?void 0:u.equalityFn)||Object.is;let v=h(r.getState());c=y=>{const g=h(y);if(!m(v,g)){const p=v;d(v=g,p)}},u!=null&&u.fireImmediately&&d(v,v)}return l(c)},o(t,i,r)},H=b;function _(o,t){let i;try{i=o()}catch{return}return{getItem:l=>{var e;const h=u=>u===null?null:JSON.parse(u,t==null?void 0:t.reviver),d=(e=i.getItem(l))!=null?e:null;return d instanceof Promise?d.then(h):h(d)},setItem:(l,e)=>i.setItem(l,JSON.stringify(e,t==null?void 0:t.replacer)),removeItem:l=>i.removeItem(l)}}const E=o=>t=>{try{const i=o(t);return i instanceof Promise?i:{then(r){return E(r)(i)},catch(r){return this}}}catch(i){return{then(r){return this},catch(r){return E(r)(i)}}}},w=(o,t)=>(i,r,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:s=>s,version:0,merge:(s,f)=>({...f,...s}),...t},h=!1;const d=new Set,u=new Set;let c;try{c=e.getStorage()}catch{}if(!c)return o((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...s)},r,l);const m=E(e.serialize),v=()=>{const s=e.partialize({...r()});let f;const n=m({state:s,version:e.version}).then(S=>c.setItem(e.name,S)).catch(S=>{f=S});if(f)throw f;return n},y=l.setState;l.setState=(s,f)=>{y(s,f),v()};const g=o((...s)=>{i(...s),v()},r,l);let p;const a=()=>{var s;if(!c)return;h=!1,d.forEach(n=>n(r()));const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,r()))||void 0;return E(c.getItem.bind(c))(e.name).then(n=>{if(n)return e.deserialize(n)}).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var S;return p=e.merge(n,(S=r())!=null?S:g),i(p,!0),v()}).then(()=>{f==null||f(p,void 0),h=!0,u.forEach(n=>n(p))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:s=>{e={...e,...s},s.getStorage&&(c=s.getStorage())},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>a(),hasHydrated:()=>h,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(u.add(s),()=>{u.delete(s)})},a(),p||g},O=(o,t)=>(i,r,l)=>{let e={storage:_(()=>localStorage),partialize:a=>a,version:0,merge:(a,s)=>({...s,...a}),...t},h=!1;const d=new Set,u=new Set;let c=e.storage;if(!c)return o((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...a)},r,l);const m=()=>{const a=e.partialize({...r()});return c.setItem(e.name,{state:a,version:e.version})},v=l.setState;l.setState=(a,s)=>{v(a,s),m()};const y=o((...a)=>{i(...a),m()},r,l);let g;const p=()=>{var a,s;if(!c)return;h=!1,d.forEach(n=>{var S;return n((S=r())!=null?S:y)});const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,(a=r())!=null?a:y))||void 0;return E(c.getItem.bind(c))(e.name).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var S;return g=e.merge(n,(S=r())!=null?S:y),i(g,!0),m()}).then(()=>{f==null||f(g,void 0),g=r(),h=!0,u.forEach(n=>n(g))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:a=>{e={...e,...a},a.storage&&(c=a.storage)},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>p(),hasHydrated:()=>h,onHydrate:a=>(d.add(a),()=>{d.delete(a)}),onFinishHydration:a=>(u.add(a),()=>{u.delete(a)})},e.skipHydration||p(),g||y},R=(o,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?w(o,t):O(o,t),z=R,I=o=>{let t;const i=new Set,r=(u,c)=>{const m=typeof u=="function"?u(t):u;if(!Object.is(m,t)){const v=t;t=c??typeof m!="object"?m:Object.assign({},t,m),i.forEach(y=>y(t,v))}},l=()=>t,d={setState:r,getState:l,subscribe:u=>(i.add(u),()=>i.delete(u)),destroy:()=>{i.clear()}};return t=o(r,l,d),d},D=o=>o?I(o):I;function P(o,t){if(Object.is(o,t))return!0;if(typeof o!="object"||o===null||typeof t!="object"||t===null)return!1;if(o instanceof Map&&t instanceof Map){if(o.size!==t.size)return!1;for(const[r,l]of o)if(!Object.is(l,t.get(r)))return!1;return!0}if(o instanceof Set&&t instanceof Set){if(o.size!==t.size)return!1;for(const r of o)if(!t.has(r))return!1;return!0}const i=Object.keys(o);if(i.length!==Object.keys(t).length)return!1;for(let r=0;r<i.length;r++)if(!Object.prototype.hasOwnProperty.call(t,i[r])||!Object.is(o[i[r]],t[i[r]]))return!1;return!0}export{H as a,D as c,z as p,P as s};
