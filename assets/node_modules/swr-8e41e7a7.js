import{a as wt,r as w}from"./react-0beb1837.js";import{s as Kt}from"./use-sync-external-store-357101f6.js";const P=()=>{},D=P(),ut=Object,a=t=>t===D,x=t=>typeof t=="function",U=(t,e)=>({...t,...e}),Gt=t=>x(t.then),ot=new WeakMap;let Yt=0;const Z=t=>{const e=typeof t,n=t&&t.constructor,r=n==Date;let s,i;if(ut(t)===t&&!r&&n!=RegExp){if(s=ot.get(t),s)return s;if(s=++Yt+"~",ot.set(t,s),n==Array){for(s="@",i=0;i<t.length;i++)s+=Z(t[i])+",";ot.set(t,s)}if(n==ut){s="#";const c=ut.keys(t).sort();for(;!a(i=c.pop());)a(t[i])||(s+=i+":"+Z(t[i])+",");ot.set(t,s)}}else s=r?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},M=new WeakMap,lt={},rt={},gt="undefined",it=typeof window!=gt,Rt=typeof document!=gt,Xt=()=>it&&typeof window.requestAnimationFrame!=gt,Mt=(t,e)=>{const n=M.get(t);return[()=>!a(e)&&t.get(e)||lt,r=>{if(!a(e)){const s=t.get(e);e in rt||(rt[e]=s),n[5](e,U(s,r),s||lt)}},n[6],()=>!a(e)&&e in rt?rt[e]:!a(e)&&t.get(e)||lt]};let ht=!0;const Qt=()=>ht,[_t,Tt]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[P,P],Zt=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},te=t=>(Rt&&document.addEventListener("visibilitychange",t),_t("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),ee=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return _t("online",e),_t("offline",n),()=>{Tt("online",e),Tt("offline",n)}},ne={isOnline:Qt,isVisible:Zt},se={initFocus:te,initReconnect:ee},Nt=!wt.useId,tt=!it||"Deno"in window,oe=t=>Xt()?window.requestAnimationFrame(t):setTimeout(t,1),ft=tt?w.useEffect:w.useLayoutEffect,dt=typeof navigator<"u"&&navigator.connection,yt=!tt&&dt&&(["slow-2g","2g"].includes(dt.effectiveType)||dt.saveData),pt=t=>{if(x(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Z(t):"",[t,e]};let re=0;const mt=()=>++re,xt=0,Pt=1,Ut=2,ie=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:ie,FOCUS_EVENT:xt,MUTATE_EVENT:Ut,RECONNECT_EVENT:Pt};async function qt(...t){const[e,n,r,s]=t,i=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=i.populateCache;const E=i.rollbackOnError;let d=i.optimisticData;const V=i.revalidate!==!1,_=O=>typeof E=="function"?E(O):E!==!1,T=i.throwOnError;if(x(n)){const O=n,g=[],v=e.keys();for(const L of v)!/^\$(inf|sub)\$/.test(L)&&O(e.get(L)._k)&&g.push(L);return Promise.all(g.map(I))}return I(n);async function I(O){const[g]=pt(O);if(!g)return;const[v,L]=Mt(e,g),[o,j,Y,q]=M.get(e),H=()=>{const S=o[g];return V&&(delete Y[g],delete q[g],S&&S[0])?S[0](Ut).then(()=>v().data):v().data};if(t.length<3)return H();let p=r,b;const R=mt();j[g]=[R,0];const k=!a(d),N=v(),z=N.data,et=N._c,$=a(et)?z:et;if(k&&(d=x(d)?d($,z):d,L({data:d,_c:$})),x(p))try{p=p($)}catch(S){b=S}if(p&&Gt(p))if(p=await p.catch(S=>{b=S}),R!==j[g][0]){if(b)throw b;return p}else b&&k&&_(b)&&(c=!0,L({data:$,_c:D}));if(c&&!b)if(x(c)){const S=c(p,$);L({data:S,error:D,_c:D})}else L({data:p,error:D,_c:D});if(j[g][1]=mt(),Promise.resolve(H()).then(()=>{L({_c:D})}),b){if(T)throw b;return}return p}}const Ft=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},ae=(t,e)=>{if(!M.has(t)){const n=U(se,e),r={},s=qt.bind(D,t);let i=P;const c={},E=(_,T)=>{const I=c[_]||[];return c[_]=I,I.push(T),()=>I.splice(I.indexOf(T),1)},d=(_,T,I)=>{t.set(_,T);const O=c[_];if(O)for(const g of O)g(T,I)},V=()=>{if(!M.has(t)&&(M.set(t,[r,{},{},{},s,d,E]),!tt)){const _=n.initFocus(setTimeout.bind(D,Ft.bind(D,r,xt))),T=n.initReconnect(setTimeout.bind(D,Ft.bind(D,r,Pt)));i=()=>{_&&_(),T&&T(),M.delete(t)}}};return V(),[t,s,V,i]}return[t,M.get(t)[4]]},ce=(t,e,n,r,s)=>{const i=n.errorRetryCount,c=s.retryCount,E=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(i)&&c>i||setTimeout(r,E,s)},ue=(t,e)=>Z(t)==Z(e),[Ht,le]=ae(new Map),fe=U({onLoadingSlow:P,onSuccess:P,onError:P,onErrorRetry:ce,onDiscarded:P,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:yt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:yt?5e3:3e3,compare:ue,isPaused:()=>!1,cache:Ht,mutate:le,fallback:{}},ne),de=(t,e)=>{const n=U(t,e);if(e){const{use:r,fallback:s}=t,{use:i,fallback:c}=e;r&&i&&(n.use=r.concat(i)),s&&c&&(n.fallback=U(s,c))}return n},Ee=w.createContext({}),Re="$inf$",$t=it&&window.__SWR_DEVTOOLS_USE__,he=$t?window.__SWR_DEVTOOLS_USE__:[],_e=()=>{$t&&(window.__SWR_DEVTOOLS_REACT__=wt)},Te=t=>x(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],me=()=>U(fe,w.useContext(Ee)),we=t=>(e,n,r)=>t(e,n&&((...i)=>{const[c]=pt(e),[,,,E]=M.get(Ht);if(c.startsWith(Re))return n(...i);const d=E[c];return a(d)?n(...i):(delete E[c],d)}),r),ge=he.concat(we),pe=t=>function(...n){const r=me(),[s,i,c]=Te(n),E=de(r,c);let d=t;const{use:V}=E,_=(V||[]).concat(ge);for(let T=_.length;T--;)d=_[T](d);return d(s,i||E.fetcher||null,E)},Se=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const s=r.indexOf(n);s>=0&&(r[s]=r[r.length-1],r.pop())}};_e();const Wt=wt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Et={dedupe:!0},Ce=(t,e,n)=>{const{cache:r,compare:s,suspense:i,fallbackData:c,revalidateOnMount:E,revalidateIfStale:d,refreshInterval:V,refreshWhenHidden:_,refreshWhenOffline:T,keepPreviousData:I}=n,[O,g,v,L]=M.get(r),[o,j]=pt(t),Y=w.useRef(!1),q=w.useRef(!1),H=w.useRef(o),p=w.useRef(e),b=w.useRef(n),R=()=>b.current,k=()=>R().isVisible()&&R().isOnline(),[N,z,et,$]=Mt(r,o),S=w.useRef({}).current,jt=a(c)?n.fallback[o]:c,St=(u,l)=>{for(const m in S){const f=m;if(f==="data"){if(!s(u[f],l[f])&&(!a(u[f])||!s(st,l[f])))return!1}else if(l[f]!==u[f])return!1}return!0},Ct=w.useMemo(()=>{const u=(()=>!o||!e?!1:a(E)?R().isPaused()||i?!1:a(d)?!0:d:E)(),l=C=>{const F=U(C);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},m=N(),f=$(),y=l(m),G=m===f?y:l(f);let h=y;return[()=>{const C=l(N());return St(C,h)?(h.data=C.data,h.isLoading=C.isLoading,h.isValidating=C.isValidating,h.error=C.error,h):(h=C,C)},()=>G]},[r,o]),B=Kt.useSyncExternalStore(w.useCallback(u=>et(o,(l,m)=>{St(m,l)||u()}),[r,o]),Ct[0],Ct[1]),Dt=!Y.current,kt=O[o]&&O[o].length>0,J=B.data,K=a(J)?jt:J,nt=B.error,Ot=w.useRef(K),st=I?a(J)?Ot.current:J:K,vt=(()=>kt&&!a(nt)?!1:Dt&&!a(E)?E:R().isPaused()?!1:i?a(K)?!1:d:a(K)||d)(),bt=!!(o&&e&&Dt&&vt),zt=a(B.isValidating)?bt:B.isValidating,Bt=a(B.isLoading)?bt:B.isLoading,X=w.useCallback(async u=>{const l=p.current;if(!o||!l||q.current||R().isPaused())return!1;let m,f,y=!0;const G=u||{},h=!v[o]||!G.dedupe,C=()=>Nt?!q.current&&o===H.current&&Y.current:o===H.current,F={isValidating:!1,isLoading:!1},Vt=()=>{z(F)},It=()=>{const A=v[o];A&&A[1]===f&&delete v[o]},Lt={isValidating:!0};a(N().data)&&(Lt.isLoading=!0);try{if(h&&(z(Lt),n.loadingTimeout&&a(N().data)&&setTimeout(()=>{y&&C()&&R().onLoadingSlow(o,n)},n.loadingTimeout),v[o]=[l(j),mt()]),[m,f]=v[o],m=await m,h&&setTimeout(It,n.dedupingInterval),!v[o]||v[o][1]!==f)return h&&C()&&R().onDiscarded(o),!1;F.error=D;const A=g[o];if(!a(A)&&(f<=A[0]||f<=A[1]||A[1]===0))return Vt(),h&&C()&&R().onDiscarded(o),!1;const W=N().data;F.data=s(W,m)?W:m,h&&C()&&R().onSuccess(m,o,n)}catch(A){It();const W=R(),{shouldRetryOnError:at}=W;W.isPaused()||(F.error=A,h&&C()&&(W.onError(A,o,W),(at===!0||x(at)&&at(A))&&k()&&W.onErrorRetry(A,o,W,Jt=>{const ct=O[o];ct&&ct[0]&&ct[0](Q.ERROR_REVALIDATE_EVENT,Jt)},{retryCount:(G.retryCount||0)+1,dedupe:!0})))}return y=!1,Vt(),!0},[o,r]),At=w.useCallback((...u)=>qt(r,H.current,...u),[]);if(ft(()=>{p.current=e,b.current=n,a(J)||(Ot.current=J)}),ft(()=>{if(!o)return;const u=X.bind(D,Et);let l=0;const f=Se(o,O,(y,G={})=>{if(y==Q.FOCUS_EVENT){const h=Date.now();R().revalidateOnFocus&&h>l&&k()&&(l=h+R().focusThrottleInterval,u())}else if(y==Q.RECONNECT_EVENT)R().revalidateOnReconnect&&k()&&u();else{if(y==Q.MUTATE_EVENT)return X();if(y==Q.ERROR_REVALIDATE_EVENT)return X(G)}});return q.current=!1,H.current=o,Y.current=!0,z({_k:j}),vt&&(a(K)||tt?u():oe(u)),()=>{q.current=!0,f()}},[o]),ft(()=>{let u;function l(){const f=x(V)?V(N().data):V;f&&u!==-1&&(u=setTimeout(m,f))}function m(){!N().error&&(_||R().isVisible())&&(T||R().isOnline())?X(Et).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[V,_,T,o]),w.useDebugValue(st),i&&a(K)&&o){if(!Nt&&tt)throw new Error("Fallback data is required when using suspense in SSR.");p.current=e,b.current=n,q.current=!1;const u=L[o];if(!a(u)){const l=At(u);Wt(l)}if(a(nt)){const l=X(Et);a(st)||(l.status="fulfilled",l.value=!0),Wt(l)}else throw nt}return{mutate:At,get data(){return S.data=!0,st},get error(){return S.error=!0,nt},get isValidating(){return S.isValidating=!0,zt},get isLoading(){return S.isLoading=!0,Bt}}},ve=pe(Ce);export{a as i,ve as u};
