import{a as St,r as R}from"./react-16b4b865.js";import{s as fe}from"./use-sync-external-store-f6026e73.js";import{g as de}from"./@adraffy-3aaa55d6.js";const U=()=>{},p=U(),et=Object,a=t=>t===p,y=t=>typeof t=="function",x=(t,e)=>({...t,...e}),kt=t=>y(t.then),ut=new WeakMap;let Ee=0;const X=t=>{const e=typeof t,n=t&&t.constructor,r=n==Date;let s,o;if(et(t)===t&&!r&&n!=RegExp){if(s=ut.get(t),s)return s;if(s=++Ee+"~",ut.set(t,s),n==Array){for(s="@",o=0;o<t.length;o++)s+=X(t[o])+",";ut.set(t,s)}if(n==et){s="#";const c=et.keys(t).sort();for(;!a(o=c.pop());)a(t[o])||(s+=o+":"+X(t[o])+",");ut.set(t,s)}}else s=r?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},N=new WeakMap,ht={},lt={},Ot="undefined",st=typeof window!=Ot,ft=typeof document!=Ot,zt=()=>st&&typeof window.requestAnimationFrame!=Ot,Dt=(t,e)=>{const n=N.get(t);return[()=>!a(e)&&t.get(e)||ht,r=>{if(!a(e)){const s=t.get(e);e in lt||(lt[e]=s),n[5](e,x(s,r),s||ht)}},n[6],()=>!a(e)&&e in lt?lt[e]:!a(e)&&t.get(e)||ht]};let Tt=!0;const Re=()=>Tt,[mt,pt]=st&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],he=()=>{const t=ft&&document.visibilityState;return a(t)||t!=="hidden"},_e=t=>(ft&&document.addEventListener("visibilitychange",t),mt("focus",t),()=>{ft&&document.removeEventListener("visibilitychange",t),pt("focus",t)}),ge=t=>{const e=()=>{Tt=!0,t()},n=()=>{Tt=!1};return mt("online",e),mt("offline",n),()=>{pt("online",e),pt("offline",n)}},Bt={isOnline:Re,isVisible:he},Jt={initFocus:_e,initReconnect:ge},Ct=!St.useId,Q=!st||"Deno"in window,Kt=t=>zt()?window.requestAnimationFrame(t):setTimeout(t,1),nt=Q?R.useEffect:R.useLayoutEffect,_t=typeof navigator<"u"&&navigator.connection,vt=!Q&&_t&&(["slow-2g","2g"].includes(_t.effectiveType)||_t.saveData),ot=t=>{if(y(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?X(t):"",[t,e]};let Te=0;const dt=()=>++Te,Gt=0,Yt=1,Xt=2,me=3;var Y={__proto__:null,ERROR_REVALIDATE_EVENT:me,FOCUS_EVENT:Gt,MUTATE_EVENT:Xt,RECONNECT_EVENT:Yt};async function bt(...t){const[e,n,r,s]=t,o=x({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=o.populateCache;const d=o.rollbackOnError;let u=o.optimisticData;const V=o.revalidate!==!1,g=O=>typeof d=="function"?d(O):d!==!1,T=o.throwOnError;if(y(n)){const O=n,C=[],D=e.keys();for(const L of D)!/^\$(inf|sub)\$/.test(L)&&O(e.get(L)._k)&&C.push(L);return Promise.all(C.map(I))}return I(n);async function I(O){const[C]=ot(O);if(!C)return;const[D,L]=Dt(e,C),[i,j,Z,q]=N.get(e),H=()=>{const w=i[C];return V&&(delete Z[C],delete q[C],w&&w[0])?w[0](Xt).then(()=>D().data):D().data};if(t.length<3)return H();let v=r,b;const h=dt();j[C]=[h,0];const k=!a(u),F=D(),z=F.data,it=F._c,$=a(it)?z:it;if(k&&(u=y(u)?u($,z):u,L({data:u,_c:$})),y(v))try{v=v($)}catch(w){b=w}if(v&&kt(v))if(v=await v.catch(w=>{b=w}),h!==j[C][0]){if(b)throw b;return v}else b&&k&&g(b)&&(c=!0,L({data:$,_c:p}));if(c&&!b)if(y(c)){const w=c(v,$);L({data:w,error:p,_c:p})}else L({data:v,error:p,_c:p});if(j[C][1]=dt(),Promise.resolve(H()).then(()=>{L({_c:p})}),b){if(T)throw b;return}return v}}const $t=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},At=(t,e)=>{if(!N.has(t)){const n=x(Jt,e),r={},s=bt.bind(p,t);let o=U;const c={},d=(g,T)=>{const I=c[g]||[];return c[g]=I,I.push(T),()=>I.splice(I.indexOf(T),1)},u=(g,T,I)=>{t.set(g,T);const O=c[g];if(O)for(const C of O)C(T,I)},V=()=>{if(!N.has(t)&&(N.set(t,[r,{},{},{},s,u,d]),!Q)){const g=n.initFocus(setTimeout.bind(p,$t.bind(p,r,Gt))),T=n.initReconnect(setTimeout.bind(p,$t.bind(p,r,Yt)));o=()=>{g&&g(),T&&T(),N.delete(t)}}};return V(),[t,s,V,o]}return[t,N.get(t)[4]]},pe=(t,e,n,r,s)=>{const o=n.errorRetryCount,c=s.retryCount,d=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(o)&&c>o||setTimeout(r,d,s)},Qt=(t,e)=>X(t)==X(e),[rt,Zt]=At(new Map),Vt=x({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:pe,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:vt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:vt?5e3:3e3,compare:Qt,isPaused:()=>!1,cache:rt,mutate:Zt,fallback:{}},Bt),It=(t,e)=>{const n=x(t,e);if(e){const{use:r,fallback:s}=t,{use:o,fallback:c}=e;r&&o&&(n.use=r.concat(o)),s&&c&&(n.fallback=x(s,c))}return n},wt=R.createContext({}),te=t=>{const{value:e}=t,n=R.useContext(wt),r=y(e),s=R.useMemo(()=>r?e(n):e,[r,n,e]),o=R.useMemo(()=>r?s:It(n,s),[r,n,s]),c=s&&s.provider,d=R.useRef(p);c&&!d.current&&(d.current=At(c(o.cache||rt),s));const u=d.current;return u&&(o.cache=u[0],o.mutate=u[1]),nt(()=>{if(u)return u[2]&&u[2](),u[3]},[]),R.createElement(wt.Provider,x(t,{value:o}))},ee="$inf$",ne=st&&window.__SWR_DEVTOOLS_USE__,Ce=ne?window.__SWR_DEVTOOLS_USE__:[],ve=()=>{ne&&(window.__SWR_DEVTOOLS_REACT__=St)},Lt=t=>y(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],se=()=>x(Vt,R.useContext(wt)),we=(t,e)=>{const[n,r]=ot(t),[,,,s]=N.get(rt);if(s[n])return s[n];const o=e(r);return s[n]=o,o},Se=t=>(e,n,r)=>t(e,n&&((...o)=>{const[c]=ot(e),[,,,d]=N.get(rt);if(c.startsWith(ee))return n(...o);const u=d[c];return a(u)?n(...o):(delete d[c],u)}),r),Oe=Ce.concat(Se),oe=t=>function(...n){const r=se(),[s,o,c]=Lt(n),d=It(r,c);let u=t;const{use:V}=d,g=(V||[]).concat(Oe);for(let T=g.length;T--;)u=g[T](u);return u(s,o||d.fetcher||null,d)},re=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const s=r.indexOf(n);s>=0&&(r[s]=r[r.length-1],r.pop())}},De=(t,e)=>(...n)=>{const[r,s,o]=Lt(n),c=(o.use||[]).concat(e);return t(r,s,{...o,use:c})};ve();const be=Object.freeze(Object.defineProperty({__proto__:null,INFINITE_PREFIX:ee,IS_REACT_LEGACY:Ct,IS_SERVER:Q,OBJECT:et,SWRConfig:te,SWRGlobalState:N,UNDEFINED:p,cache:rt,compare:Qt,createCacheHelper:Dt,defaultConfig:Vt,defaultConfigOptions:Jt,getTimestamp:dt,hasRequestAnimationFrame:zt,initCache:At,internalMutate:bt,isDocumentDefined:ft,isFunction:y,isPromiseLike:kt,isUndefined:a,isWindowDefined:st,mergeConfigs:It,mergeObjects:x,mutate:Zt,noop:U,normalize:Lt,preload:we,preset:Bt,rAF:Kt,revalidateEvents:Y,serialize:ot,slowConnection:vt,stableHash:X,subscribeCallback:re,useIsomorphicLayoutEffect:nt,useSWRConfig:se,withArgs:oe,withMiddleware:De},Symbol.toStringTag,{value:"Module"})),jt=St.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),gt={dedupe:!0},Ae=(t,e,n)=>{const{cache:r,compare:s,suspense:o,fallbackData:c,revalidateOnMount:d,revalidateIfStale:u,refreshInterval:V,refreshWhenHidden:g,refreshWhenOffline:T,keepPreviousData:I}=n,[O,C,D,L]=N.get(r),[i,j]=ot(t),Z=R.useRef(!1),q=R.useRef(!1),H=R.useRef(i),v=R.useRef(e),b=R.useRef(n),h=()=>b.current,k=()=>h().isVisible()&&h().isOnline(),[F,z,it,$]=Dt(r,i),w=R.useRef({}).current,ie=a(c)?n.fallback[i]:c,Nt=(l,f)=>{for(const m in w){const E=m;if(E==="data"){if(!s(l[E],f[E])&&(!a(l[E])||!s(ct,f[E])))return!1}else if(f[E]!==l[E])return!1}return!0},yt=R.useMemo(()=>{const l=(()=>!i||!e?!1:a(d)?h().isPaused()||o?!1:a(u)?!0:u:d)(),f=S=>{const P=x(S);return delete P._k,l?{isValidating:!0,isLoading:!0,...P}:P},m=F(),E=$(),M=f(m),G=m===E?M:f(E);let _=M;return[()=>{const S=f(F());return Nt(S,_)?(_.data=S.data,_.isLoading=S.isLoading,_.isValidating=S.isValidating,_.error=S.error,_):(_=S,S)},()=>G]},[r,i]),B=fe.useSyncExternalStore(R.useCallback(l=>it(i,(f,m)=>{Nt(m,f)||l()}),[r,i]),yt[0],yt[1]),Ft=!Z.current,ae=O[i]&&O[i].length>0,J=B.data,K=a(J)?ie:J,at=B.error,Mt=R.useRef(K),ct=I?a(J)?Mt.current:J:K,xt=(()=>ae&&!a(at)?!1:Ft&&!a(d)?d:h().isPaused()?!1:o?a(K)?!1:u:a(K)||u)(),Pt=!!(i&&e&&Ft&&xt),ce=a(B.isValidating)?Pt:B.isValidating,ue=a(B.isLoading)?Pt:B.isLoading,tt=R.useCallback(async l=>{const f=v.current;if(!i||!f||q.current||h().isPaused())return!1;let m,E,M=!0;const G=l||{},_=!D[i]||!G.dedupe,S=()=>Ct?!q.current&&i===H.current&&Z.current:i===H.current,P={isValidating:!1,isLoading:!1},Ut=()=>{z(P)},qt=()=>{const A=D[i];A&&A[1]===E&&delete D[i]},Ht={isValidating:!0};a(F().data)&&(Ht.isLoading=!0);try{if(_&&(z(Ht),n.loadingTimeout&&a(F().data)&&setTimeout(()=>{M&&S()&&h().onLoadingSlow(i,n)},n.loadingTimeout),D[i]=[f(j),dt()]),[m,E]=D[i],m=await m,_&&setTimeout(qt,n.dedupingInterval),!D[i]||D[i][1]!==E)return _&&S()&&h().onDiscarded(i),!1;P.error=p;const A=C[i];if(!a(A)&&(E<=A[0]||E<=A[1]||A[1]===0))return Ut(),_&&S()&&h().onDiscarded(i),!1;const W=F().data;P.data=s(W,m)?W:m,_&&S()&&h().onSuccess(m,i,n)}catch(A){qt();const W=h(),{shouldRetryOnError:Et}=W;W.isPaused()||(P.error=A,_&&S()&&(W.onError(A,i,W),(Et===!0||y(Et)&&Et(A))&&k()&&W.onErrorRetry(A,i,W,le=>{const Rt=O[i];Rt&&Rt[0]&&Rt[0](Y.ERROR_REVALIDATE_EVENT,le)},{retryCount:(G.retryCount||0)+1,dedupe:!0})))}return M=!1,Ut(),!0},[i,r]),Wt=R.useCallback((...l)=>bt(r,H.current,...l),[]);if(nt(()=>{v.current=e,b.current=n,a(J)||(Mt.current=J)}),nt(()=>{if(!i)return;const l=tt.bind(p,gt);let f=0;const E=re(i,O,(M,G={})=>{if(M==Y.FOCUS_EVENT){const _=Date.now();h().revalidateOnFocus&&_>f&&k()&&(f=_+h().focusThrottleInterval,l())}else if(M==Y.RECONNECT_EVENT)h().revalidateOnReconnect&&k()&&l();else{if(M==Y.MUTATE_EVENT)return tt();if(M==Y.ERROR_REVALIDATE_EVENT)return tt(G)}});return q.current=!1,H.current=i,Z.current=!0,z({_k:j}),xt&&(a(K)||Q?l():Kt(l)),()=>{q.current=!0,E()}},[i]),nt(()=>{let l;function f(){const E=y(V)?V(F().data):V;E&&l!==-1&&(l=setTimeout(m,E))}function m(){!F().error&&(g||h().isVisible())&&(T||h().isOnline())?tt(gt).then(f):f()}return f(),()=>{l&&(clearTimeout(l),l=-1)}},[V,g,T,i]),R.useDebugValue(ct),o&&a(K)&&i){if(!Ct&&Q)throw new Error("Fallback data is required when using suspense in SSR.");v.current=e,b.current=n,q.current=!1;const l=L[i];if(!a(l)){const f=Wt(l);jt(f)}if(a(at)){const f=tt(gt);a(ct)||(f.status="fulfilled",f.value=!0),jt(f)}else throw at}return{mutate:Wt,get data(){return w.data=!0,ct},get error(){return w.error=!0,at},get isValidating(){return w.isValidating=!0,ce},get isLoading(){return w.isLoading=!0,ue}}};et.defineProperty(te,"defaultValue",{value:Vt});const Ne=oe(Ae),ye=de(be);export{a as i,ye as r,Ne as u};
