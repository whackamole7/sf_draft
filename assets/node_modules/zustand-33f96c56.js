const p=o=>(t,a,r)=>{const l=r.subscribe;return r.subscribe=(h,d,u)=>{let c=h;if(d){const v=(u==null?void 0:u.equalityFn)||Object.is;let m=h(r.getState());c=y=>{const g=h(y);if(!v(m,g)){const _=m;d(m=g,_)}},u!=null&&u.fireImmediately&&d(m,m)}return l(c)},o(t,a,r)},H=p;function b(o,t){let a;try{a=o()}catch{return}return{getItem:l=>{var e;const h=u=>u===null?null:JSON.parse(u,t==null?void 0:t.reviver),d=(e=a.getItem(l))!=null?e:null;return d instanceof Promise?d.then(h):h(d)},setItem:(l,e)=>a.setItem(l,JSON.stringify(e,t==null?void 0:t.replacer)),removeItem:l=>a.removeItem(l)}}const E=o=>t=>{try{const a=o(t);return a instanceof Promise?a:{then(r){return E(r)(a)},catch(r){return this}}}catch(a){return{then(r){return this},catch(r){return E(r)(a)}}}},P=(o,t)=>(a,r,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:s=>s,version:0,merge:(s,f)=>({...f,...s}),...t},h=!1;const d=new Set,u=new Set;let c;try{c=e.getStorage()}catch{}if(!c)return o((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...s)},r,l);const v=E(e.serialize),m=()=>{const s=e.partialize({...r()});let f;const n=v({state:s,version:e.version}).then(S=>c.setItem(e.name,S)).catch(S=>{f=S});if(f)throw f;return n},y=l.setState;l.setState=(s,f)=>{y(s,f),m()};const g=o((...s)=>{a(...s),m()},r,l);let _;const i=()=>{var s;if(!c)return;h=!1,d.forEach(n=>n(r()));const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,r()))||void 0;return E(c.getItem.bind(c))(e.name).then(n=>{if(n)return e.deserialize(n)}).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var S;return _=e.merge(n,(S=r())!=null?S:g),a(_,!0),m()}).then(()=>{f==null||f(_,void 0),h=!0,u.forEach(n=>n(_))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:s=>{e={...e,...s},s.getStorage&&(c=s.getStorage())},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>i(),hasHydrated:()=>h,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(u.add(s),()=>{u.delete(s)})},i(),_||g},R=(o,t)=>(a,r,l)=>{let e={storage:b(()=>localStorage),partialize:i=>i,version:0,merge:(i,s)=>({...s,...i}),...t},h=!1;const d=new Set,u=new Set;let c=e.storage;if(!c)return o((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...i)},r,l);const v=()=>{const i=e.partialize({...r()});return c.setItem(e.name,{state:i,version:e.version})},m=l.setState;l.setState=(i,s)=>{m(i,s),v()};const y=o((...i)=>{a(...i),v()},r,l);let g;const _=()=>{var i,s;if(!c)return;h=!1,d.forEach(n=>{var S;return n((S=r())!=null?S:y)});const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,(i=r())!=null?i:y))||void 0;return E(c.getItem.bind(c))(e.name).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var S;return g=e.merge(n,(S=r())!=null?S:y),a(g,!0),v()}).then(()=>{f==null||f(g,void 0),g=r(),h=!0,u.forEach(n=>n(g))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:i=>{e={...e,...i},i.storage&&(c=i.storage)},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>_(),hasHydrated:()=>h,onHydrate:i=>(d.add(i),()=>{d.delete(i)}),onFinishHydration:i=>(u.add(i),()=>{u.delete(i)})},e.skipHydration||_(),g||y},w=(o,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?P(o,t):R(o,t),O=w,I=o=>{let t;const a=new Set,r=(u,c)=>{const v=typeof u=="function"?u(t):u;if(!Object.is(v,t)){const m=t;t=c??(typeof v!="object"||v===null)?v:Object.assign({},t,v),a.forEach(y=>y(t,m))}},l=()=>t,d={setState:r,getState:l,subscribe:u=>(a.add(u),()=>a.delete(u)),destroy:()=>{a.clear()}};return t=o(r,l,d),d},T=o=>o?I(o):I;function Y(o,t){if(Object.is(o,t))return!0;if(typeof o!="object"||o===null||typeof t!="object"||t===null)return!1;if(o instanceof Map&&t instanceof Map){if(o.size!==t.size)return!1;for(const[r,l]of o)if(!Object.is(l,t.get(r)))return!1;return!0}if(o instanceof Set&&t instanceof Set){if(o.size!==t.size)return!1;for(const r of o)if(!t.has(r))return!1;return!0}const a=Object.keys(o);if(a.length!==Object.keys(t).length)return!1;for(let r=0;r<a.length;r++)if(!Object.prototype.hasOwnProperty.call(t,a[r])||!Object.is(o[a[r]],t[a[r]]))return!1;return!0}export{H as a,T as c,O as p,Y as s};
