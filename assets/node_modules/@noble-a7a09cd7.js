import{g as St}from"./@adraffy-3aaa55d6.js";function Pt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function ae(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function pn(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Pt(t.outputLen),Pt(t.blockLen)}function Bt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function De(t,e){ae(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Nt=BigInt(2**32-1),Ae=BigInt(32);function mn(t,e=!1){return e?{h:Number(t&Nt),l:Number(t>>Ae&Nt)}:{h:Number(t>>Ae&Nt)|0,l:Number(t&Nt)|0}}function En(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:o}=mn(t[s],e);[n[s],r[s]]=[i,o]}return[n,r]}const Bn=(t,e,n)=>t<<n|e>>>32-n,An=(t,e,n)=>e<<n|t>>>32-n,_n=(t,e,n)=>e<<n-32|t>>>64-n,Sn=(t,e,n)=>t<<n-32|e>>>64-n,jt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,Ln=Object.freeze(Object.defineProperty({__proto__:null,crypto:jt},Symbol.toStringTag,{value:"Module"}));/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ge=t=>t instanceof Uint8Array,Hn=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),Jt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),at=(t,e)=>t<<32-e|t>>>e,In=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!In)throw new Error("Non little-endian hardware is not supported");function vn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Tt(t){if(typeof t=="string"&&(t=vn(t)),!Ge(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function kn(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!Ge(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class fe{clone(){return this._cloneInto()}}function Zt(t){const e=r=>t().update(Tt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function On(t){const e=(r,s)=>t(s).update(Tt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function Ze(t=32){if(jt&&typeof jt.getRandomValues=="function")return jt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}const[We,Ke,ze]=[[],[],[]],Un=BigInt(0),It=BigInt(1),Tn=BigInt(2),qn=BigInt(7),Cn=BigInt(256),Nn=BigInt(113);for(let t=0,e=It,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],We.push(2*(5*r+n)),Ke.push((t+1)*(t+2)/2%64);let s=Un;for(let i=0;i<7;i++)e=(e<<It^(e>>qn)*Nn)%Cn,e&Tn&&(s^=It<<(It<<BigInt(i))-It);ze.push(s)}const[$n,Rn]=En(ze,!0),_e=(t,e,n)=>n>32?_n(t,e,n):Bn(t,e,n),Se=(t,e,n)=>n>32?Sn(t,e,n):An(t,e,n);function Ye(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let o=0;o<10;o++)n[o]=t[o]^t[o+10]^t[o+20]^t[o+30]^t[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,f=(o+2)%10,h=n[f],b=n[f+1],a=_e(h,b,1)^n[c],m=Se(h,b,1)^n[c+1];for(let g=0;g<50;g+=10)t[o+g]^=a,t[o+g+1]^=m}let s=t[2],i=t[3];for(let o=0;o<24;o++){const c=Ke[o],f=_e(s,i,c),h=Se(s,i,c),b=We[o];s=t[b],i=t[b+1],t[b]=f,t[b+1]=h}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)n[c]=t[o+c];for(let c=0;c<10;c++)t[o+c]^=~n[(c+2)%10]&n[(c+4)%10]}t[0]^=$n[r],t[1]^=Rn[r]}n.fill(0)}class qt extends fe{constructor(e,n,r,s=!1,i=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=s,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Pt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Hn(this.state)}keccak(){Ye(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){Bt(this);const{blockLen:n,state:r}=this;e=Tt(e);const s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);for(let c=0;c<o;c++)r[this.pos++]^=e[i++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:r,blockLen:s}=this;e[r]^=n,n&128&&r===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Bt(this,!1),ae(e),this.finish();const n=this.state,{blockLen:r}=this;for(let s=0,i=e.length;s<i;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,i-s);e.set(n.subarray(this.posOut,this.posOut+o),s),this.posOut+=o,s+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Pt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(De(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:n,suffix:r,outputLen:s,rounds:i,enableXOF:o}=this;return e||(e=new qt(n,r,s,o,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=s,e.enableXOF=o,e.destroyed=this.destroyed,e}}const xt=(t,e,n)=>Zt(()=>new qt(e,t,n)),jn=xt(6,144,224/8),Pn=xt(6,136,256/8),Mn=xt(6,104,384/8),Vn=xt(6,72,512/8),Dn=xt(1,144,224/8),Gn=xt(1,136,256/8),Zn=xt(1,104,384/8),Wn=xt(1,72,512/8),Xe=(t,e,n)=>On((r={})=>new qt(e,t,r.dkLen===void 0?n:r.dkLen,!0)),Kn=Xe(31,168,128/8),zn=Xe(31,136,256/8),Yn=Object.freeze(Object.defineProperty({__proto__:null,Keccak:qt,keccakP:Ye,keccak_224:Dn,keccak_256:Gn,keccak_384:Zn,keccak_512:Wn,sha3_224:jn,sha3_256:Pn,sha3_384:Mn,sha3_512:Vn,shake128:Kn,shake256:zn},Symbol.toStringTag,{value:"Module"}));function Xn(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(n>>s&i),c=Number(n&i),f=r?4:0,h=r?0:4;t.setUint32(e+f,o,r),t.setUint32(e+h,c,r)}class Qe extends fe{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Jt(this.buffer)}update(e){Bt(this);const{view:n,buffer:r,blockLen:s}=this;e=Tt(e);const i=e.length;for(let o=0;o<i;){const c=Math.min(s-this.pos,i-o);if(c===s){const f=Jt(e);for(;s<=i-o;o+=s)this.process(f,o);continue}r.set(e.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Bt(this),De(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;n[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(r,0),o=0);for(let a=o;a<s;a++)n[a]=0;Xn(r,s-8,BigInt(this.length*8),i),this.process(r,0);const c=Jt(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=f/4,b=this.get();if(h>b.length)throw new Error("_sha2: outputLen bigger than state");for(let a=0;a<h;a++)c.setUint32(4*a,b[a],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:i,destroyed:o,pos:c}=this;return e.length=s,e.pos=c,e.finished=i,e.destroyed=o,s%n&&e.buffer.set(r),e}}const Qn=(t,e,n)=>t&e^~t&n,Jn=(t,e,n)=>t&e^t&n^e&n,Fn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ft=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ut=new Uint32Array(64);class Je extends Qe{constructor(){super(64,32,8,!1),this.A=ft[0]|0,this.B=ft[1]|0,this.C=ft[2]|0,this.D=ft[3]|0,this.E=ft[4]|0,this.F=ft[5]|0,this.G=ft[6]|0,this.H=ft[7]|0}get(){const{A:e,B:n,C:r,D:s,E:i,F:o,G:c,H:f}=this;return[e,n,r,s,i,o,c,f]}set(e,n,r,s,i,o,c,f){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=c|0,this.H=f|0}process(e,n){for(let a=0;a<16;a++,n+=4)ut[a]=e.getUint32(n,!1);for(let a=16;a<64;a++){const m=ut[a-15],g=ut[a-2],x=at(m,7)^at(m,18)^m>>>3,u=at(g,17)^at(g,19)^g>>>10;ut[a]=u+ut[a-7]+x+ut[a-16]|0}let{A:r,B:s,C:i,D:o,E:c,F:f,G:h,H:b}=this;for(let a=0;a<64;a++){const m=at(c,6)^at(c,11)^at(c,25),g=b+m+Qn(c,f,h)+Fn[a]+ut[a]|0,u=(at(r,2)^at(r,13)^at(r,22))+Jn(r,s,i)|0;b=h,h=f,f=c,c=o+g|0,o=i,i=s,s=r,r=g+u|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,c=c+this.E|0,f=f+this.F|0,h=h+this.G|0,b=b+this.H|0,this.set(r,s,i,o,c,f,h,b)}roundClean(){ut.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class tr extends Je{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const kt=Zt(()=>new Je),er=Zt(()=>new tr),nr=Object.freeze(Object.defineProperty({__proto__:null,sha224:er,sha256:kt},Symbol.toStringTag,{value:"Module"})),rr=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Fe=Uint8Array.from({length:16},(t,e)=>e),sr=Fe.map(t=>(9*t+5)%16);let ue=[Fe],le=[sr];for(let t=0;t<4;t++)for(let e of[ue,le])e.push(e[t].map(n=>rr[n]));const tn=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),or=ue.map((t,e)=>t.map(n=>tn[e][n])),ir=le.map((t,e)=>t.map(n=>tn[e][n])),cr=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),ar=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),$t=(t,e)=>t<<e|t>>>32-e;function Le(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}const Rt=new Uint32Array(16);class en extends Qe{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:n,h2:r,h3:s,h4:i}=this;return[e,n,r,s,i]}set(e,n,r,s,i){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=s|0,this.h4=i|0}process(e,n){for(let g=0;g<16;g++,n+=4)Rt[g]=e.getUint32(n,!0);let r=this.h0|0,s=r,i=this.h1|0,o=i,c=this.h2|0,f=c,h=this.h3|0,b=h,a=this.h4|0,m=a;for(let g=0;g<5;g++){const x=4-g,u=cr[g],d=ar[g],y=ue[g],w=le[g],B=or[g],_=ir[g];for(let H=0;H<16;H++){const l=$t(r+Le(g,i,c,h)+Rt[y[H]]+u,B[H])+a|0;r=a,a=h,h=$t(c,10)|0,c=i,i=l}for(let H=0;H<16;H++){const l=$t(s+Le(x,o,f,b)+Rt[w[H]]+d,_[H])+m|0;s=m,m=b,b=$t(f,10)|0,f=o,o=l}}this.set(this.h1+c+b|0,this.h2+h+m|0,this.h3+a+s|0,this.h4+r+o|0,this.h0+i+f|0)}roundClean(){Rt.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const fr=Zt(()=>new en),ur=Object.freeze(Object.defineProperty({__proto__:null,RIPEMD160:en,ripemd160:fr},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nn=BigInt(0),Wt=BigInt(1),lr=BigInt(2),Kt=t=>t instanceof Uint8Array,hr=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function At(t){if(!Kt(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=hr[t[n]];return e}function rn(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function he(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function _t(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,i=t.slice(s,s+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");n[r]=o}return n}function J(t){return he(At(t))}function de(t){if(!Kt(t))throw new Error("Uint8Array expected");return he(At(Uint8Array.from(t).reverse()))}function dt(t,e){return _t(t.toString(16).padStart(e*2,"0"))}function be(t,e){return dt(t,e).reverse()}function dr(t){return _t(rn(t))}function X(t,e,n){let r;if(typeof e=="string")try{r=_t(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(Kt(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(`${t} expected ${n} bytes, got ${s}`);return r}function rt(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!Kt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function br(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function zt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function xr(t){let e;for(e=0;t>nn;t>>=Wt,e+=1);return e}function gr(t,e){return t>>BigInt(e)&Wt}const yr=(t,e,n)=>t|(n?Wt:nn)<<BigInt(e),xe=t=>(lr<<BigInt(t-1))-Wt,Ft=t=>new Uint8Array(t),He=t=>Uint8Array.from(t);function sn(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Ft(t),s=Ft(t),i=0;const o=()=>{r.fill(1),s.fill(0),i=0},c=(...a)=>n(s,r,...a),f=(a=Ft())=>{s=c(He([0]),a),r=c(),a.length!==0&&(s=c(He([1]),a),r=c())},h=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let a=0;const m=[];for(;a<e;){r=c();const g=r.slice();m.push(g),a+=r.length}return rt(...m)};return(a,m)=>{o(),f(a);let g;for(;!(g=m(h()));)f();return o(),g}}const wr={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Lt(t,e,n={}){const r=(s,i,o)=>{const c=wr[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const f=t[s];if(!(o&&f===void 0)&&!c(f,t))throw new Error(`Invalid param ${String(s)}=${f} (${typeof f}), expected ${i}`)};for(const[s,i]of Object.entries(e))r(s,i,!1);for(const[s,i]of Object.entries(n))r(s,i,!0);return t}const pr=Object.freeze(Object.defineProperty({__proto__:null,bitGet:gr,bitLen:xr,bitMask:xe,bitSet:yr,bytesToHex:At,bytesToNumberBE:J,bytesToNumberLE:de,concatBytes:rt,createHmacDrbg:sn,ensureBytes:X,equalBytes:br,hexToBytes:_t,hexToNumber:he,numberToBytesBE:dt,numberToBytesLE:be,numberToHexUnpadded:rn,numberToVarBytesBE:dr,utf8ToBytes:zt,validateObject:Lt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),V=BigInt(1),pt=BigInt(2),mr=BigInt(3),se=BigInt(4),Ie=BigInt(5),ve=BigInt(8);BigInt(9);BigInt(16);function G(t,e){const n=t%e;return n>=Z?n:e+n}function Er(t,e,n){if(n<=Z||e<Z)throw new Error("Expected power/modulo > 0");if(n===V)return Z;let r=V;for(;e>Z;)e&V&&(r=r*t%n),t=t*t%n,e>>=V;return r}function st(t,e,n){let r=t;for(;e-- >Z;)r*=r,r%=n;return r}function oe(t,e){if(t===Z||e<=Z)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=G(t,e),r=e,s=Z,i=V;for(;n!==Z;){const c=r/n,f=r%n,h=s-i*c;r=n,n=f,s=i,i=h}if(r!==V)throw new Error("invert: does not exist");return G(s,e)}function Br(t){const e=(t-V)/pt;let n,r,s;for(n=t-V,r=0;n%pt===Z;n/=pt,r++);for(s=pt;s<t&&Er(s,e,t)!==t-V;s++);if(r===1){const o=(t+V)/se;return function(f,h){const b=f.pow(h,o);if(!f.eql(f.sqr(b),h))throw new Error("Cannot find square root");return b}}const i=(n+V)/pt;return function(c,f){if(c.pow(f,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let h=r,b=c.pow(c.mul(c.ONE,s),n),a=c.pow(f,i),m=c.pow(f,n);for(;!c.eql(m,c.ONE);){if(c.eql(m,c.ZERO))return c.ZERO;let g=1;for(let u=c.sqr(m);g<h&&!c.eql(u,c.ONE);g++)u=c.sqr(u);const x=c.pow(b,V<<BigInt(h-g-1));b=c.sqr(x),a=c.mul(a,x),m=c.mul(m,b),h=g}return a}}function Ar(t){if(t%se===mr){const e=(t+V)/se;return function(r,s){const i=r.pow(s,e);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(t%ve===Ie){const e=(t-Ie)/ve;return function(r,s){const i=r.mul(s,pt),o=r.pow(i,e),c=r.mul(s,o),f=r.mul(r.mul(c,pt),o),h=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(h),s))throw new Error("Cannot find square root");return h}}return Br(t)}const _r=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function on(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=_r.reduce((r,s)=>(r[s]="function",r),e);return Lt(t,n)}function Sr(t,e,n){if(n<Z)throw new Error("Expected power > 0");if(n===Z)return t.ONE;if(n===V)return e;let r=t.ONE,s=e;for(;n>Z;)n&V&&(r=t.mul(r,s)),s=t.sqr(s),n>>=V;return r}function Lr(t,e){const n=new Array(e.length),r=e.reduce((i,o,c)=>t.is0(o)?i:(n[c]=i,t.mul(i,o)),t.ONE),s=t.inv(r);return e.reduceRight((i,o,c)=>t.is0(o)?i:(n[c]=t.mul(i,n[c]),t.mul(i,o)),s),n}function cn(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Hr(t,e,n=!1,r={}){if(t<=Z)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:i}=cn(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const o=Ar(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:i,MASK:xe(s),ZERO:Z,ONE:V,create:f=>G(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return Z<=f&&f<t},is0:f=>f===Z,isOdd:f=>(f&V)===V,neg:f=>G(-f,t),eql:(f,h)=>f===h,sqr:f=>G(f*f,t),add:(f,h)=>G(f+h,t),sub:(f,h)=>G(f-h,t),mul:(f,h)=>G(f*h,t),pow:(f,h)=>Sr(c,f,h),div:(f,h)=>G(f*oe(h,t),t),sqrN:f=>f*f,addN:(f,h)=>f+h,subN:(f,h)=>f-h,mulN:(f,h)=>f*h,inv:f=>oe(f,t),sqrt:r.sqrt||(f=>o(c,f)),invertBatch:f=>Lr(c,f),cmov:(f,h,b)=>b?h:f,toBytes:f=>n?be(f,i):dt(f,i),fromBytes:f=>{if(f.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${f.length}`);return n?de(f):J(f)}});return Object.freeze(c)}function an(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function fn(t){const e=an(t);return e+Math.ceil(e/2)}function Ir(t,e,n=!1){const r=t.length,s=an(e),i=fn(e);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const o=n?J(t):de(t),c=G(o,e-V)+V;return n?be(c,s):dt(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vr=BigInt(0),te=BigInt(1);function kr(t,e){const n=(s,i)=>{const o=i.negate();return s?o:i},r=s=>{const i=Math.ceil(e/s)+1,o=2**(s-1);return{windows:i,windowSize:o}};return{constTimeNegate:n,unsafeLadder(s,i){let o=t.ZERO,c=s;for(;i>vr;)i&te&&(o=o.add(c)),c=c.double(),i>>=te;return o},precomputeWindow(s,i){const{windows:o,windowSize:c}=r(i),f=[];let h=s,b=h;for(let a=0;a<o;a++){b=h,f.push(b);for(let m=1;m<c;m++)b=b.add(h),f.push(b);h=b.double()}return f},wNAF(s,i,o){const{windows:c,windowSize:f}=r(s);let h=t.ZERO,b=t.BASE;const a=BigInt(2**s-1),m=2**s,g=BigInt(s);for(let x=0;x<c;x++){const u=x*f;let d=Number(o&a);o>>=g,d>f&&(d-=m,o+=te);const y=u,w=u+Math.abs(d)-1,B=x%2!==0,_=d<0;d===0?b=b.add(n(B,i[y])):h=h.add(n(_,i[w]))}return{p:h,f:b}},wNAFCached(s,i,o,c){const f=s._WINDOW_SIZE||1;let h=i.get(s);return h||(h=this.precomputeWindow(s,f),f!==1&&i.set(s,c(h))),this.wNAF(f,h,o)}}}function un(t){return on(t.Fp),Lt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...cn(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Or(t){const e=un(t);Lt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ur,hexToBytes:Tr}=pr,mt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=mt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ur(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=mt,n=typeof t=="string"?Tr(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:i}=mt._parseInt(n.subarray(2)),{d:o,l:c}=mt._parseInt(i);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:o}},hexFromSig(t){const e=h=>Number.parseInt(h[0],16)&8?"00"+h:h,n=h=>{const b=h.toString(16);return b.length&1?`0${b}`:b},r=e(n(t.s)),s=e(n(t.r)),i=r.length/2,o=s.length/2,c=n(i),f=n(o);return`30${n(o+i+4)}02${f}${s}02${c}${r}`}},it=BigInt(0),P=BigInt(1),lt=BigInt(2),Mt=BigInt(3),ke=BigInt(4);function qr(t){const e=Or(t),{Fp:n}=e,r=e.toBytes||((x,u,d)=>{const y=u.toAffine();return rt(Uint8Array.from([4]),n.toBytes(y.x),n.toBytes(y.y))}),s=e.fromBytes||(x=>{const u=x.subarray(1),d=n.fromBytes(u.subarray(0,n.BYTES)),y=n.fromBytes(u.subarray(n.BYTES,2*n.BYTES));return{x:d,y}});function i(x){const{a:u,b:d}=e,y=n.sqr(x),w=n.mul(y,x);return n.add(n.add(w,n.mul(x,u)),d)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function o(x){return typeof x=="bigint"&&it<x&&x<e.n}function c(x){if(!o(x))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(x){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:y,n:w}=e;if(u&&typeof x!="bigint"){if(x instanceof Uint8Array&&(x=At(x)),typeof x!="string"||!u.includes(x.length))throw new Error("Invalid key");x=x.padStart(d*2,"0")}let B;try{B=typeof x=="bigint"?x:J(X("private key",x,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof x}`)}return y&&(B=G(B,w)),c(B),B}const h=new Map;function b(x){if(!(x instanceof a))throw new Error("ProjectivePoint expected")}class a{constructor(u,d,y){if(this.px=u,this.py=d,this.pz=y,u==null||!n.isValid(u))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(y==null||!n.isValid(y))throw new Error("z required")}static fromAffine(u){const{x:d,y}=u||{};if(!u||!n.isValid(d)||!n.isValid(y))throw new Error("invalid affine point");if(u instanceof a)throw new Error("projective point not allowed");const w=B=>n.eql(B,n.ZERO);return w(d)&&w(y)?a.ZERO:new a(d,y,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=n.invertBatch(u.map(y=>y.pz));return u.map((y,w)=>y.toAffine(d[w])).map(a.fromAffine)}static fromHex(u){const d=a.fromAffine(s(X("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return a.BASE.multiply(f(u))}_setWindowSize(u){this._WINDOW_SIZE=u,h.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:d}=this.toAffine();if(!n.isValid(u)||!n.isValid(d))throw new Error("bad point: x or y not FE");const y=n.sqr(d),w=i(u);if(!n.eql(y,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(n.isOdd)return!n.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){b(u);const{px:d,py:y,pz:w}=this,{px:B,py:_,pz:H}=u,l=n.eql(n.mul(d,H),n.mul(B,w)),p=n.eql(n.mul(y,H),n.mul(_,w));return l&&p}negate(){return new a(this.px,n.neg(this.py),this.pz)}double(){const{a:u,b:d}=e,y=n.mul(d,Mt),{px:w,py:B,pz:_}=this;let H=n.ZERO,l=n.ZERO,p=n.ZERO,S=n.mul(w,w),E=n.mul(B,B),A=n.mul(_,_),L=n.mul(w,B);return L=n.add(L,L),p=n.mul(w,_),p=n.add(p,p),H=n.mul(u,p),l=n.mul(y,A),l=n.add(H,l),H=n.sub(E,l),l=n.add(E,l),l=n.mul(H,l),H=n.mul(L,H),p=n.mul(y,p),A=n.mul(u,A),L=n.sub(S,A),L=n.mul(u,L),L=n.add(L,p),p=n.add(S,S),S=n.add(p,S),S=n.add(S,A),S=n.mul(S,L),l=n.add(l,S),A=n.mul(B,_),A=n.add(A,A),S=n.mul(A,L),H=n.sub(H,S),p=n.mul(A,E),p=n.add(p,p),p=n.add(p,p),new a(H,l,p)}add(u){b(u);const{px:d,py:y,pz:w}=this,{px:B,py:_,pz:H}=u;let l=n.ZERO,p=n.ZERO,S=n.ZERO;const E=e.a,A=n.mul(e.b,Mt);let L=n.mul(d,B),k=n.mul(y,_),T=n.mul(w,H),C=n.add(d,y),I=n.add(B,_);C=n.mul(C,I),I=n.add(L,k),C=n.sub(C,I),I=n.add(d,w);let v=n.add(B,H);return I=n.mul(I,v),v=n.add(L,T),I=n.sub(I,v),v=n.add(y,w),l=n.add(_,H),v=n.mul(v,l),l=n.add(k,T),v=n.sub(v,l),S=n.mul(E,I),l=n.mul(A,T),S=n.add(l,S),l=n.sub(k,S),S=n.add(k,S),p=n.mul(l,S),k=n.add(L,L),k=n.add(k,L),T=n.mul(E,T),I=n.mul(A,I),k=n.add(k,T),T=n.sub(L,T),T=n.mul(E,T),I=n.add(I,T),L=n.mul(k,I),p=n.add(p,L),L=n.mul(v,I),l=n.mul(C,l),l=n.sub(l,L),L=n.mul(C,k),S=n.mul(v,S),S=n.add(S,L),new a(l,p,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(a.ZERO)}wNAF(u){return g.wNAFCached(this,h,u,d=>{const y=n.invertBatch(d.map(w=>w.pz));return d.map((w,B)=>w.toAffine(y[B])).map(a.fromAffine)})}multiplyUnsafe(u){const d=a.ZERO;if(u===it)return d;if(c(u),u===P)return this;const{endo:y}=e;if(!y)return g.unsafeLadder(this,u);let{k1neg:w,k1:B,k2neg:_,k2:H}=y.splitScalar(u),l=d,p=d,S=this;for(;B>it||H>it;)B&P&&(l=l.add(S)),H&P&&(p=p.add(S)),S=S.double(),B>>=P,H>>=P;return w&&(l=l.negate()),_&&(p=p.negate()),p=new a(n.mul(p.px,y.beta),p.py,p.pz),l.add(p)}multiply(u){c(u);let d=u,y,w;const{endo:B}=e;if(B){const{k1neg:_,k1:H,k2neg:l,k2:p}=B.splitScalar(d);let{p:S,f:E}=this.wNAF(H),{p:A,f:L}=this.wNAF(p);S=g.constTimeNegate(_,S),A=g.constTimeNegate(l,A),A=new a(n.mul(A.px,B.beta),A.py,A.pz),y=S.add(A),w=E.add(L)}else{const{p:_,f:H}=this.wNAF(d);y=_,w=H}return a.normalizeZ([y,w])[0]}multiplyAndAddUnsafe(u,d,y){const w=a.BASE,B=(H,l)=>l===it||l===P||!H.equals(w)?H.multiplyUnsafe(l):H.multiply(l),_=B(this,d).add(B(u,y));return _.is0()?void 0:_}toAffine(u){const{px:d,py:y,pz:w}=this,B=this.is0();u==null&&(u=B?n.ONE:n.inv(w));const _=n.mul(d,u),H=n.mul(y,u),l=n.mul(w,u);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(l,n.ONE))throw new Error("invZ was invalid");return{x:_,y:H}}isTorsionFree(){const{h:u,isTorsionFree:d}=e;if(u===P)return!0;if(d)return d(a,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=e;return u===P?this:d?d(a,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return this.assertValidity(),r(a,this,u)}toHex(u=!0){return At(this.toRawBytes(u))}}a.BASE=new a(e.Gx,e.Gy,n.ONE),a.ZERO=new a(n.ZERO,n.ONE,n.ZERO);const m=e.nBitLength,g=kr(a,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:a,normPrivateKeyToScalar:f,weierstrassEquation:i,isWithinCurveOrder:o}}function Cr(t){const e=un(t);return Lt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Nr(t){const e=Cr(t),{Fp:n,n:r}=e,s=n.BYTES+1,i=2*n.BYTES+1;function o(I){return it<I&&I<n.ORDER}function c(I){return G(I,r)}function f(I){return oe(I,r)}const{ProjectivePoint:h,normPrivateKeyToScalar:b,weierstrassEquation:a,isWithinCurveOrder:m}=qr({...e,toBytes(I,v,O){const N=v.toAffine(),q=n.toBytes(N.x),$=rt;return O?$(Uint8Array.from([v.hasEvenY()?2:3]),q):$(Uint8Array.from([4]),q,n.toBytes(N.y))},fromBytes(I){const v=I.length,O=I[0],N=I.subarray(1);if(v===s&&(O===2||O===3)){const q=J(N);if(!o(q))throw new Error("Point is not on curve");const $=a(q);let R=n.sqrt($);const j=(R&P)===P;return(O&1)===1!==j&&(R=n.neg(R)),{x:q,y:R}}else if(v===i&&O===4){const q=n.fromBytes(N.subarray(0,n.BYTES)),$=n.fromBytes(N.subarray(n.BYTES,2*n.BYTES));return{x:q,y:$}}else throw new Error(`Point of length ${v} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)}}),g=I=>At(dt(I,e.nByteLength));function x(I){const v=r>>P;return I>v}function u(I){return x(I)?c(-I):I}const d=(I,v,O)=>J(I.slice(v,O));class y{constructor(v,O,N){this.r=v,this.s=O,this.recovery=N,this.assertValidity()}static fromCompact(v){const O=e.nByteLength;return v=X("compactSignature",v,O*2),new y(d(v,0,O),d(v,O,2*O))}static fromDER(v){const{r:O,s:N}=mt.toSig(X("DER",v));return new y(O,N)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(v){return new y(this.r,this.s,v)}recoverPublicKey(v){const{r:O,s:N,recovery:q}=this,$=p(X("msgHash",v));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const R=q===2||q===3?O+e.n:O;if(R>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=q&1?"03":"02",M=h.fromHex(j+g(R)),D=f(R),W=c(-$*D),K=c(N*D),z=h.BASE.multiplyAndAddUnsafe(M,W,K);if(!z)throw new Error("point at infinify");return z.assertValidity(),z}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return _t(this.toDERHex())}toDERHex(){return mt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return _t(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const w={isValidPrivateKey(I){try{return b(I),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const I=fn(e.n);return Ir(e.randomBytes(I),e.n)},precompute(I=8,v=h.BASE){return v._setWindowSize(I),v.multiply(BigInt(3)),v}};function B(I,v=!0){return h.fromPrivateKey(I).toRawBytes(v)}function _(I){const v=I instanceof Uint8Array,O=typeof I=="string",N=(v||O)&&I.length;return v?N===s||N===i:O?N===2*s||N===2*i:I instanceof h}function H(I,v,O=!0){if(_(I))throw new Error("first arg must be private key");if(!_(v))throw new Error("second arg must be public key");return h.fromHex(v).multiply(b(I)).toRawBytes(O)}const l=e.bits2int||function(I){const v=J(I),O=I.length*8-e.nBitLength;return O>0?v>>BigInt(O):v},p=e.bits2int_modN||function(I){return c(l(I))},S=xe(e.nBitLength);function E(I){if(typeof I!="bigint")throw new Error("bigint expected");if(!(it<=I&&I<S))throw new Error(`bigint expected < 2^${e.nBitLength}`);return dt(I,e.nByteLength)}function A(I,v,O=L){if(["recovered","canonical"].some(Q=>Q in O))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:q}=e;let{lowS:$,prehash:R,extraEntropy:j}=O;$==null&&($=!0),I=X("msgHash",I),R&&(I=X("prehashed msgHash",N(I)));const M=p(I),D=b(v),W=[E(D),E(M)];if(j!=null){const Q=j===!0?q(n.BYTES):j;W.push(X("extraEntropy",Q))}const K=rt(...W),z=M;function ot(Q){const F=l(Q);if(!m(F))return;const ct=f(F),tt=h.BASE.multiply(F).toAffine(),et=c(tt.x);if(et===it)return;const Et=c(ct*c(z+et*D));if(Et===it)return;let Ee=(tt.x===et?0:2)|Number(tt.y&P),Be=Et;return $&&x(Et)&&(Be=u(Et),Ee^=1),new y(et,Be,Ee)}return{seed:K,k2sig:ot}}const L={lowS:e.lowS,prehash:!1},k={lowS:e.lowS,prehash:!1};function T(I,v,O=L){const{seed:N,k2sig:q}=A(I,v,O),$=e;return sn($.hash.outputLen,$.nByteLength,$.hmac)(N,q)}h.BASE._setWindowSize(8);function C(I,v,O,N=k){var tt;const q=I;if(v=X("msgHash",v),O=X("publicKey",O),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:R}=N;let j,M;try{if(typeof q=="string"||q instanceof Uint8Array)try{j=y.fromDER(q)}catch(et){if(!(et instanceof mt.Err))throw et;j=y.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:et,s:Et}=q;j=new y(et,Et)}else throw new Error("PARSE");M=h.fromHex(O)}catch(et){if(et.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;R&&(v=e.hash(v));const{r:D,s:W}=j,K=p(v),z=f(W),ot=c(K*z),Q=c(D*z),F=(tt=h.BASE.multiplyAndAddUnsafe(M,ot,Q))==null?void 0:tt.toAffine();return F?c(F.x)===D:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:H,sign:T,verify:C,ProjectivePoint:h,Signature:y,utils:w}}function $r(t,e){const n=t.ORDER;let r=it;for(let x=n-P;x%lt===it;x/=lt)r+=P;const s=r,i=lt<<s-P-P,o=i*lt,c=(n-P)/o,f=(c-P)/lt,h=o-P,b=i,a=t.pow(e,c),m=t.pow(e,(c+P)/lt);let g=(x,u)=>{let d=a,y=t.pow(u,h),w=t.sqr(y);w=t.mul(w,u);let B=t.mul(x,w);B=t.pow(B,f),B=t.mul(B,y),y=t.mul(B,u),w=t.mul(B,x);let _=t.mul(w,y);B=t.pow(_,b);let H=t.eql(B,t.ONE);y=t.mul(w,m),B=t.mul(_,d),w=t.cmov(y,w,H),_=t.cmov(B,_,H);for(let l=s;l>P;l--){let p=l-lt;p=lt<<p-P;let S=t.pow(_,p);const E=t.eql(S,t.ONE);y=t.mul(w,d),d=t.mul(d,d),S=t.mul(_,d),w=t.cmov(y,w,E),_=t.cmov(S,_,E)}return{isValid:H,value:w}};if(t.ORDER%ke===Mt){const x=(t.ORDER-Mt)/ke,u=t.sqrt(t.neg(e));g=(d,y)=>{let w=t.sqr(y);const B=t.mul(d,y);w=t.mul(w,B);let _=t.pow(w,x);_=t.mul(_,B);const H=t.mul(_,u),l=t.mul(t.sqr(_),y),p=t.eql(l,d);let S=t.cmov(H,_,p);return{isValid:p,value:S}}}return g}function Rr(t,e){if(on(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=$r(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,o,c,f,h,b,a;s=t.sqr(r),s=t.mul(s,e.Z),i=t.sqr(s),i=t.add(i,s),o=t.add(i,t.ONE),o=t.mul(o,e.B),c=t.cmov(e.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,e.A),i=t.sqr(o),h=t.sqr(c),f=t.mul(h,e.A),i=t.add(i,f),i=t.mul(i,o),h=t.mul(h,c),f=t.mul(h,e.B),i=t.add(i,f),b=t.mul(s,o);const{isValid:m,value:g}=n(i,h);a=t.mul(s,r),a=t.mul(a,g),b=t.cmov(b,o,m),a=t.cmov(a,g,m);const x=t.isOdd(r)===t.isOdd(a);return a=t.cmov(t.neg(a),a,x),b=t.div(b,c),{x:b,y:a}}}function jr(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return zt(t);throw new Error("DST must be Uint8Array or string")}const Pr=J;function ht(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function Mr(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function Ot(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function ge(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Vr(t,e,n,r){Ot(t),Ot(e),ge(n),e.length>255&&(e=r(rt(zt("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:i}=r,o=Math.ceil(n/s);if(o>255)throw new Error("Invalid xmd length");const c=rt(e,ht(e.length,1)),f=ht(0,i),h=ht(n,2),b=new Array(o),a=r(rt(f,t,h,ht(0,1),c));b[0]=r(rt(a,ht(1,1),c));for(let g=1;g<=o;g++){const x=[Mr(a,b[g-1]),ht(g+1,1),c];b[g]=r(rt(...x))}return rt(...b).slice(0,n)}function Dr(t,e,n,r,s){if(Ot(t),Ot(e),ge(n),e.length>255){const i=Math.ceil(2*r/8);e=s.create({dkLen:i}).update(zt("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(ht(n,2)).update(e).update(ht(e.length,1)).digest()}function Oe(t,e,n){Lt(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:i,hash:o,expand:c,DST:f}=n;Ot(t),ge(e);const h=jr(f),b=r.toString(2).length,a=Math.ceil((b+s)/8),m=e*i*a;let g;if(c==="xmd")g=Vr(t,h,m,o);else if(c==="xof")g=Dr(t,h,m,s,o);else if(c==="_internal_pass")g=t;else throw new Error('expand must be "xmd" or "xof"');const x=new Array(e);for(let u=0;u<e;u++){const d=new Array(i);for(let y=0;y<i;y++){const w=a*(y+u*i),B=g.subarray(w,w+a);d[y]=G(Pr(B),r)}x[u]=d}return x}function Gr(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,s)=>{const[i,o,c,f]=n.map(h=>h.reduce((b,a)=>t.add(t.mul(b,r),a)));return r=t.div(i,o),s=t.mul(s,t.div(c,f)),{x:r,y:s}}}function Zr(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const i=Oe(r,2,{...n,DST:n.DST,...s}),o=t.fromAffine(e(i[0])),c=t.fromAffine(e(i[1])),f=o.add(c).clearCofactor();return f.assertValidity(),f},encodeToCurve(r,s){const i=Oe(r,1,{...n,DST:n.encodeDST,...s}),o=t.fromAffine(e(i[0])).clearCofactor();return o.assertValidity(),o}}}class ye extends fe{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,pn(e);const r=Tt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),i.fill(0)}update(e){return Bt(this),this.iHash.update(e),this}digestInto(e){Bt(this),ae(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const we=(t,e,n)=>new ye(t,e).update(n).digest();we.create=(t,e)=>new ye(t,e);const Wr=Object.freeze(Object.defineProperty({__proto__:null,HMAC:ye,hmac:we},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Kr(t){return{hash:t,hmac:(e,...n)=>we(t,e,kn(...n)),randomBytes:Ze}}function zr(t,e){const n=r=>Nr({...t,...Kr(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Vt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ln=BigInt(1),Dt=BigInt(2),Ue=(t,e)=>(t+e/Dt)/e;function hn(t){const e=Yt,n=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),f=BigInt(88),h=t*t*t%e,b=h*h*t%e,a=st(b,n,e)*b%e,m=st(a,n,e)*b%e,g=st(m,Dt,e)*h%e,x=st(g,s,e)*g%e,u=st(x,i,e)*x%e,d=st(u,c,e)*u%e,y=st(d,f,e)*d%e,w=st(y,c,e)*u%e,B=st(w,n,e)*b%e,_=st(B,o,e)*x%e,H=st(_,r,e)*h%e,l=st(H,Dt,e);if(!bt.eql(bt.sqr(l),t))throw new Error("Cannot find square root");return l}const bt=Hr(Yt,void 0,void 0,{sqrt:hn}),Ct=zr({a:BigInt(0),b:BigInt(7),Fp:bt,n:Vt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Vt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ln*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,o=BigInt("0x100000000000000000000000000000000"),c=Ue(i*t,e),f=Ue(-r*t,e);let h=G(t-c*n-f*s,e),b=G(-c*r-f*i,e);const a=h>o,m=b>o;if(a&&(h=e-h),m&&(b=e-b),h>o||b>o)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:a,k1:h,k2neg:m,k2:b}}}},kt),Xt=BigInt(0),dn=t=>typeof t=="bigint"&&Xt<t&&t<Yt,Yr=t=>typeof t=="bigint"&&Xt<t&&t<Vt,Te={};function Gt(t,...e){let n=Te[t];if(n===void 0){const r=kt(Uint8Array.from(t,s=>s.charCodeAt(0)));n=rt(r,r),Te[t]=n}return kt(rt(n,...e))}const pe=t=>t.toRawBytes(!0).slice(1),ie=t=>dt(t,32),ee=t=>G(t,Yt),Ut=t=>G(t,Vt),me=Ct.ProjectivePoint,Xr=(t,e,n)=>me.BASE.multiplyAndAddUnsafe(t,e,n);function ce(t){let e=Ct.utils.normPrivateKeyToScalar(t),n=me.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:Ut(-e),bytes:pe(n)}}function bn(t){if(!dn(t))throw new Error("bad x: need 0 < x < p");const e=ee(t*t),n=ee(e*t+BigInt(7));let r=hn(n);r%Dt!==Xt&&(r=ee(-r));const s=new me(t,r,ln);return s.assertValidity(),s}function xn(...t){return Ut(J(Gt("BIP0340/challenge",...t)))}function Qr(t){return ce(t).bytes}function Jr(t,e,n=Ze(32)){const r=X("message",t),{bytes:s,scalar:i}=ce(e),o=X("auxRand",n,32),c=ie(i^J(Gt("BIP0340/aux",o))),f=Gt("BIP0340/nonce",c,s,r),h=Ut(J(f));if(h===Xt)throw new Error("sign failed: k is zero");const{bytes:b,scalar:a}=ce(h),m=xn(b,s,r),g=new Uint8Array(64);if(g.set(b,0),g.set(ie(Ut(a+m*i)),32),!gn(g,r,s))throw new Error("sign: Invalid signature produced");return g}function gn(t,e,n){const r=X("signature",t,64),s=X("message",e),i=X("publicKey",n,32);try{const o=bn(J(i)),c=J(r.subarray(0,32));if(!dn(c))return!1;const f=J(r.subarray(32,64));if(!Yr(f))return!1;const h=xn(ie(c),pe(o),s),b=Xr(o,f,Ut(-h));return!(!b||!b.hasEvenY()||b.toAffine().x!==c)}catch{return!1}}const Fr=(()=>({getPublicKey:Qr,sign:Jr,verify:gn,utils:{randomPrivateKey:Ct.utils.randomPrivateKey,lift_x:bn,pointToBytes:pe,numberToBytesBE:dt,bytesToNumberBE:J,taggedHash:Gt,mod:G}}))(),ts=(()=>Gr(bt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))))(),es=(()=>Rr(bt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:bt.create(BigInt("-11"))}))(),yn=(()=>Zr(Ct.ProjectivePoint,t=>{const{x:e,y:n}=es(bt.create(t[0]));return ts(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:bt.ORDER,m:1,k:128,expand:"xmd",hash:kt}))(),ns=(()=>yn.hashToCurve)(),rs=(()=>yn.encodeToCurve)(),ss=Object.freeze(Object.defineProperty({__proto__:null,encodeToCurve:rs,hashToCurve:ns,schnorr:Fr,secp256k1:Ct},Symbol.toStringTag,{value:"Module"})),hs=St(Wr);var gt={},Y={},qe;function Qt(){if(qe)return Y;qe=1,Object.defineProperty(Y,"__esModule",{value:!0}),Y.output=Y.exists=Y.hash=Y.bytes=Y.bool=Y.number=void 0;function t(c){if(!Number.isSafeInteger(c)||c<0)throw new Error(`Wrong positive integer: ${c}`)}Y.number=t;function e(c){if(typeof c!="boolean")throw new Error(`Expected boolean, not ${c}`)}Y.bool=e;function n(c,...f){if(!(c instanceof Uint8Array))throw new Error("Expected Uint8Array");if(f.length>0&&!f.includes(c.length))throw new Error(`Expected Uint8Array of length ${f}, not of length=${c.length}`)}Y.bytes=n;function r(c){if(typeof c!="function"||typeof c.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");t(c.outputLen),t(c.blockLen)}Y.hash=r;function s(c,f=!0){if(c.destroyed)throw new Error("Hash instance has been destroyed");if(f&&c.finished)throw new Error("Hash#digest() has already been called")}Y.exists=s;function i(c,f){n(c);const h=f.outputLen;if(c.length<h)throw new Error(`digestInto() expects output buffer of length at least ${h}`)}Y.output=i;const o={number:t,bool:e,bytes:n,hash:r,exists:s,output:i};return Y.default=o,Y}var ne={},re={};const os=St(Ln);var Ce;function Ht(){return Ce||(Ce=1,function(t){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.randomBytes=t.wrapXOFConstructorWithOpts=t.wrapConstructorWithOpts=t.wrapConstructor=t.checkOpts=t.Hash=t.concatBytes=t.toBytes=t.utf8ToBytes=t.asyncLoop=t.nextTick=t.hexToBytes=t.bytesToHex=t.isLE=t.rotr=t.createView=t.u32=t.u8=void 0;const e=os,n=l=>l instanceof Uint8Array,r=l=>new Uint8Array(l.buffer,l.byteOffset,l.byteLength);t.u8=r;const s=l=>new Uint32Array(l.buffer,l.byteOffset,Math.floor(l.byteLength/4));t.u32=s;const i=l=>new DataView(l.buffer,l.byteOffset,l.byteLength);t.createView=i;const o=(l,p)=>l<<32-p|l>>>p;if(t.rotr=o,t.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,!t.isLE)throw new Error("Non little-endian hardware is not supported");const c=Array.from({length:256},(l,p)=>p.toString(16).padStart(2,"0"));function f(l){if(!n(l))throw new Error("Uint8Array expected");let p="";for(let S=0;S<l.length;S++)p+=c[l[S]];return p}t.bytesToHex=f;function h(l){if(typeof l!="string")throw new Error("hex string expected, got "+typeof l);const p=l.length;if(p%2)throw new Error("padded hex string expected, got unpadded hex of length "+p);const S=new Uint8Array(p/2);for(let E=0;E<S.length;E++){const A=E*2,L=l.slice(A,A+2),k=Number.parseInt(L,16);if(Number.isNaN(k)||k<0)throw new Error("Invalid byte sequence");S[E]=k}return S}t.hexToBytes=h;const b=async()=>{};t.nextTick=b;async function a(l,p,S){let E=Date.now();for(let A=0;A<l;A++){S(A);const L=Date.now()-E;L>=0&&L<p||(await(0,t.nextTick)(),E+=L)}}t.asyncLoop=a;function m(l){if(typeof l!="string")throw new Error(`utf8ToBytes expected string, got ${typeof l}`);return new Uint8Array(new TextEncoder().encode(l))}t.utf8ToBytes=m;function g(l){if(typeof l=="string"&&(l=m(l)),!n(l))throw new Error(`expected Uint8Array, got ${typeof l}`);return l}t.toBytes=g;function x(...l){const p=new Uint8Array(l.reduce((E,A)=>E+A.length,0));let S=0;return l.forEach(E=>{if(!n(E))throw new Error("Uint8Array expected");p.set(E,S),S+=E.length}),p}t.concatBytes=x;class u{clone(){return this._cloneInto()}}t.Hash=u;const d={}.toString;function y(l,p){if(p!==void 0&&d.call(p)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(l,p)}t.checkOpts=y;function w(l){const p=E=>l().update(g(E)).digest(),S=l();return p.outputLen=S.outputLen,p.blockLen=S.blockLen,p.create=()=>l(),p}t.wrapConstructor=w;function B(l){const p=(E,A)=>l(A).update(g(E)).digest(),S=l({});return p.outputLen=S.outputLen,p.blockLen=S.blockLen,p.create=E=>l(E),p}t.wrapConstructorWithOpts=B;function _(l){const p=(E,A)=>l(A).update(g(E)).digest(),S=l({});return p.outputLen=S.outputLen,p.blockLen=S.blockLen,p.create=E=>l(E),p}t.wrapXOFConstructorWithOpts=_;function H(l=32){if(e.crypto&&typeof e.crypto.getRandomValues=="function")return e.crypto.getRandomValues(new Uint8Array(l));throw new Error("crypto.getRandomValues must be defined")}t.randomBytes=H}(re)),re}var Ne;function is(){return Ne||(Ne=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.hmac=t.HMAC=void 0;const e=Qt(),n=Ht();class r extends n.Hash{constructor(o,c){super(),this.finished=!1,this.destroyed=!1,(0,e.hash)(o);const f=(0,n.toBytes)(c);if(this.iHash=o.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const h=this.blockLen,b=new Uint8Array(h);b.set(f.length>h?o.create().update(f).digest():f);for(let a=0;a<b.length;a++)b[a]^=54;this.iHash.update(b),this.oHash=o.create();for(let a=0;a<b.length;a++)b[a]^=106;this.oHash.update(b),b.fill(0)}update(o){return(0,e.exists)(this),this.iHash.update(o),this}digestInto(o){(0,e.exists)(this),(0,e.bytes)(o,this.outputLen),this.finished=!0,this.iHash.digestInto(o),this.oHash.update(o),this.oHash.digestInto(o),this.destroy()}digest(){const o=new Uint8Array(this.oHash.outputLen);return this.digestInto(o),o}_cloneInto(o){o||(o=Object.create(Object.getPrototypeOf(this),{}));const{oHash:c,iHash:f,finished:h,destroyed:b,blockLen:a,outputLen:m}=this;return o=o,o.finished=h,o.destroyed=b,o.blockLen=a,o.outputLen=m,o.oHash=c._cloneInto(o.oHash),o.iHash=f._cloneInto(o.iHash),o}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}t.HMAC=r;const s=(i,o,c)=>new r(i,o).update(c).digest();t.hmac=s,t.hmac.create=(i,o)=>new r(i,o)}(ne)),ne}var $e;function cs(){if($e)return gt;$e=1,Object.defineProperty(gt,"__esModule",{value:!0}),gt.pbkdf2Async=gt.pbkdf2=void 0;const t=Qt(),e=is(),n=Ht();function r(c,f,h,b){(0,t.hash)(c);const a=(0,n.checkOpts)({dkLen:32,asyncTick:10},b),{c:m,dkLen:g,asyncTick:x}=a;if((0,t.number)(m),(0,t.number)(g),(0,t.number)(x),m<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const u=(0,n.toBytes)(f),d=(0,n.toBytes)(h),y=new Uint8Array(g),w=e.hmac.create(c,u),B=w._cloneInto().update(d);return{c:m,dkLen:g,asyncTick:x,DK:y,PRF:w,PRFSalt:B}}function s(c,f,h,b,a){return c.destroy(),f.destroy(),b&&b.destroy(),a.fill(0),h}function i(c,f,h,b){const{c:a,dkLen:m,DK:g,PRF:x,PRFSalt:u}=r(c,f,h,b);let d;const y=new Uint8Array(4),w=(0,n.createView)(y),B=new Uint8Array(x.outputLen);for(let _=1,H=0;H<m;_++,H+=x.outputLen){const l=g.subarray(H,H+x.outputLen);w.setInt32(0,_,!1),(d=u._cloneInto(d)).update(y).digestInto(B),l.set(B.subarray(0,l.length));for(let p=1;p<a;p++){x._cloneInto(d).update(B).digestInto(B);for(let S=0;S<l.length;S++)l[S]^=B[S]}}return s(x,u,g,d,B)}gt.pbkdf2=i;async function o(c,f,h,b){const{c:a,dkLen:m,asyncTick:g,DK:x,PRF:u,PRFSalt:d}=r(c,f,h,b);let y;const w=new Uint8Array(4),B=(0,n.createView)(w),_=new Uint8Array(u.outputLen);for(let H=1,l=0;l<m;H++,l+=u.outputLen){const p=x.subarray(l,l+u.outputLen);B.setInt32(0,H,!1),(y=d._cloneInto(y)).update(w).digestInto(_),p.set(_.subarray(0,p.length)),await(0,n.asyncLoop)(a-1,g,()=>{u._cloneInto(y).update(_).digestInto(_);for(let S=0;S<p.length;S++)p[S]^=_[S]})}return s(u,d,x,y,_)}return gt.pbkdf2Async=o,gt}const ds=St(nr);var nt={},vt={},Re;function wn(){if(Re)return vt;Re=1,Object.defineProperty(vt,"__esModule",{value:!0}),vt.SHA2=void 0;const t=Qt(),e=Ht();function n(s,i,o,c){if(typeof s.setBigUint64=="function")return s.setBigUint64(i,o,c);const f=BigInt(32),h=BigInt(4294967295),b=Number(o>>f&h),a=Number(o&h),m=c?4:0,g=c?0:4;s.setUint32(i+m,b,c),s.setUint32(i+g,a,c)}class r extends e.Hash{constructor(i,o,c,f){super(),this.blockLen=i,this.outputLen=o,this.padOffset=c,this.isLE=f,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(i),this.view=(0,e.createView)(this.buffer)}update(i){(0,t.exists)(this);const{view:o,buffer:c,blockLen:f}=this;i=(0,e.toBytes)(i);const h=i.length;for(let b=0;b<h;){const a=Math.min(f-this.pos,h-b);if(a===f){const m=(0,e.createView)(i);for(;f<=h-b;b+=f)this.process(m,b);continue}c.set(i.subarray(b,b+a),this.pos),this.pos+=a,b+=a,this.pos===f&&(this.process(o,0),this.pos=0)}return this.length+=i.length,this.roundClean(),this}digestInto(i){(0,t.exists)(this),(0,t.output)(i,this),this.finished=!0;const{buffer:o,view:c,blockLen:f,isLE:h}=this;let{pos:b}=this;o[b++]=128,this.buffer.subarray(b).fill(0),this.padOffset>f-b&&(this.process(c,0),b=0);for(let u=b;u<f;u++)o[u]=0;n(c,f-8,BigInt(this.length*8),h),this.process(c,0);const a=(0,e.createView)(i),m=this.outputLen;if(m%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const g=m/4,x=this.get();if(g>x.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<g;u++)a.setUint32(4*u,x[u],h)}digest(){const{buffer:i,outputLen:o}=this;this.digestInto(i);const c=i.slice(0,o);return this.destroy(),c}_cloneInto(i){i||(i=new this.constructor),i.set(...this.get());const{blockLen:o,buffer:c,length:f,finished:h,destroyed:b,pos:a}=this;return i.length=f,i.pos=a,i.finished=h,i.destroyed=b,f%o&&i.buffer.set(c),i}}return vt.SHA2=r,vt}var U={},je;function as(){if(je)return U;je=1,Object.defineProperty(U,"__esModule",{value:!0}),U.add5L=U.add5H=U.add4H=U.add4L=U.add3H=U.add3L=U.add=U.rotlBL=U.rotlBH=U.rotlSL=U.rotlSH=U.rotr32L=U.rotr32H=U.rotrBL=U.rotrBH=U.rotrSL=U.rotrSH=U.shrSL=U.shrSH=U.toBig=U.split=U.fromBig=void 0;const t=BigInt(2**32-1),e=BigInt(32);function n(E,A=!1){return A?{h:Number(E&t),l:Number(E>>e&t)}:{h:Number(E>>e&t)|0,l:Number(E&t)|0}}U.fromBig=n;function r(E,A=!1){let L=new Uint32Array(E.length),k=new Uint32Array(E.length);for(let T=0;T<E.length;T++){const{h:C,l:I}=n(E[T],A);[L[T],k[T]]=[C,I]}return[L,k]}U.split=r;const s=(E,A)=>BigInt(E>>>0)<<e|BigInt(A>>>0);U.toBig=s;const i=(E,A,L)=>E>>>L;U.shrSH=i;const o=(E,A,L)=>E<<32-L|A>>>L;U.shrSL=o;const c=(E,A,L)=>E>>>L|A<<32-L;U.rotrSH=c;const f=(E,A,L)=>E<<32-L|A>>>L;U.rotrSL=f;const h=(E,A,L)=>E<<64-L|A>>>L-32;U.rotrBH=h;const b=(E,A,L)=>E>>>L-32|A<<64-L;U.rotrBL=b;const a=(E,A)=>A;U.rotr32H=a;const m=(E,A)=>E;U.rotr32L=m;const g=(E,A,L)=>E<<L|A>>>32-L;U.rotlSH=g;const x=(E,A,L)=>A<<L|E>>>32-L;U.rotlSL=x;const u=(E,A,L)=>A<<L-32|E>>>64-L;U.rotlBH=u;const d=(E,A,L)=>E<<L-32|A>>>64-L;U.rotlBL=d;function y(E,A,L,k){const T=(A>>>0)+(k>>>0);return{h:E+L+(T/2**32|0)|0,l:T|0}}U.add=y;const w=(E,A,L)=>(E>>>0)+(A>>>0)+(L>>>0);U.add3L=w;const B=(E,A,L,k)=>A+L+k+(E/2**32|0)|0;U.add3H=B;const _=(E,A,L,k)=>(E>>>0)+(A>>>0)+(L>>>0)+(k>>>0);U.add4L=_;const H=(E,A,L,k,T)=>A+L+k+T+(E/2**32|0)|0;U.add4H=H;const l=(E,A,L,k,T)=>(E>>>0)+(A>>>0)+(L>>>0)+(k>>>0)+(T>>>0);U.add5L=l;const p=(E,A,L,k,T,C)=>A+L+k+T+C+(E/2**32|0)|0;U.add5H=p;const S={fromBig:n,split:r,toBig:s,shrSH:i,shrSL:o,rotrSH:c,rotrSL:f,rotrBH:h,rotrBL:b,rotr32H:a,rotr32L:m,rotlSH:g,rotlSL:x,rotlBH:u,rotlBL:d,add:y,add3L:w,add3H:B,add4L:_,add4H:H,add5H:p,add5L:l};return U.default=S,U}var Pe;function bs(){if(Pe)return nt;Pe=1,Object.defineProperty(nt,"__esModule",{value:!0}),nt.sha384=nt.sha512_256=nt.sha512_224=nt.sha512=nt.SHA512=void 0;const t=wn(),e=as(),n=Ht(),[r,s]=(()=>e.default.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(a=>BigInt(a))))(),i=new Uint32Array(80),o=new Uint32Array(80);class c extends t.SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:m,Al:g,Bh:x,Bl:u,Ch:d,Cl:y,Dh:w,Dl:B,Eh:_,El:H,Fh:l,Fl:p,Gh:S,Gl:E,Hh:A,Hl:L}=this;return[m,g,x,u,d,y,w,B,_,H,l,p,S,E,A,L]}set(m,g,x,u,d,y,w,B,_,H,l,p,S,E,A,L){this.Ah=m|0,this.Al=g|0,this.Bh=x|0,this.Bl=u|0,this.Ch=d|0,this.Cl=y|0,this.Dh=w|0,this.Dl=B|0,this.Eh=_|0,this.El=H|0,this.Fh=l|0,this.Fl=p|0,this.Gh=S|0,this.Gl=E|0,this.Hh=A|0,this.Hl=L|0}process(m,g){for(let C=0;C<16;C++,g+=4)i[C]=m.getUint32(g),o[C]=m.getUint32(g+=4);for(let C=16;C<80;C++){const I=i[C-15]|0,v=o[C-15]|0,O=e.default.rotrSH(I,v,1)^e.default.rotrSH(I,v,8)^e.default.shrSH(I,v,7),N=e.default.rotrSL(I,v,1)^e.default.rotrSL(I,v,8)^e.default.shrSL(I,v,7),q=i[C-2]|0,$=o[C-2]|0,R=e.default.rotrSH(q,$,19)^e.default.rotrBH(q,$,61)^e.default.shrSH(q,$,6),j=e.default.rotrSL(q,$,19)^e.default.rotrBL(q,$,61)^e.default.shrSL(q,$,6),M=e.default.add4L(N,j,o[C-7],o[C-16]),D=e.default.add4H(M,O,R,i[C-7],i[C-16]);i[C]=D|0,o[C]=M|0}let{Ah:x,Al:u,Bh:d,Bl:y,Ch:w,Cl:B,Dh:_,Dl:H,Eh:l,El:p,Fh:S,Fl:E,Gh:A,Gl:L,Hh:k,Hl:T}=this;for(let C=0;C<80;C++){const I=e.default.rotrSH(l,p,14)^e.default.rotrSH(l,p,18)^e.default.rotrBH(l,p,41),v=e.default.rotrSL(l,p,14)^e.default.rotrSL(l,p,18)^e.default.rotrBL(l,p,41),O=l&S^~l&A,N=p&E^~p&L,q=e.default.add5L(T,v,N,s[C],o[C]),$=e.default.add5H(q,k,I,O,r[C],i[C]),R=q|0,j=e.default.rotrSH(x,u,28)^e.default.rotrBH(x,u,34)^e.default.rotrBH(x,u,39),M=e.default.rotrSL(x,u,28)^e.default.rotrBL(x,u,34)^e.default.rotrBL(x,u,39),D=x&d^x&w^d&w,W=u&y^u&B^y&B;k=A|0,T=L|0,A=S|0,L=E|0,S=l|0,E=p|0,{h:l,l:p}=e.default.add(_|0,H|0,$|0,R|0),_=w|0,H=B|0,w=d|0,B=y|0,d=x|0,y=u|0;const K=e.default.add3L(R,M,W);x=e.default.add3H(K,$,j,D),u=K|0}({h:x,l:u}=e.default.add(this.Ah|0,this.Al|0,x|0,u|0)),{h:d,l:y}=e.default.add(this.Bh|0,this.Bl|0,d|0,y|0),{h:w,l:B}=e.default.add(this.Ch|0,this.Cl|0,w|0,B|0),{h:_,l:H}=e.default.add(this.Dh|0,this.Dl|0,_|0,H|0),{h:l,l:p}=e.default.add(this.Eh|0,this.El|0,l|0,p|0),{h:S,l:E}=e.default.add(this.Fh|0,this.Fl|0,S|0,E|0),{h:A,l:L}=e.default.add(this.Gh|0,this.Gl|0,A|0,L|0),{h:k,l:T}=e.default.add(this.Hh|0,this.Hl|0,k|0,T|0),this.set(x,u,d,y,w,B,_,H,l,p,S,E,A,L,k,T)}roundClean(){i.fill(0),o.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}nt.SHA512=c;class f extends c{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class h extends c{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class b extends c{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}return nt.sha512=(0,n.wrapConstructor)(()=>new c),nt.sha512_224=(0,n.wrapConstructor)(()=>new f),nt.sha512_256=(0,n.wrapConstructor)(()=>new h),nt.sha384=(0,n.wrapConstructor)(()=>new b),nt}const xs=St(Yn),gs=St(ur);var yt={},wt={},Me;function fs(){if(Me)return wt;Me=1,Object.defineProperty(wt,"__esModule",{value:!0}),wt.sha224=wt.sha256=void 0;const t=wn(),e=Ht(),n=(h,b,a)=>h&b^~h&a,r=(h,b,a)=>h&b^h&a^b&a,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),i=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),o=new Uint32Array(64);class c extends t.SHA2{constructor(){super(64,32,8,!1),this.A=i[0]|0,this.B=i[1]|0,this.C=i[2]|0,this.D=i[3]|0,this.E=i[4]|0,this.F=i[5]|0,this.G=i[6]|0,this.H=i[7]|0}get(){const{A:b,B:a,C:m,D:g,E:x,F:u,G:d,H:y}=this;return[b,a,m,g,x,u,d,y]}set(b,a,m,g,x,u,d,y){this.A=b|0,this.B=a|0,this.C=m|0,this.D=g|0,this.E=x|0,this.F=u|0,this.G=d|0,this.H=y|0}process(b,a){for(let _=0;_<16;_++,a+=4)o[_]=b.getUint32(a,!1);for(let _=16;_<64;_++){const H=o[_-15],l=o[_-2],p=(0,e.rotr)(H,7)^(0,e.rotr)(H,18)^H>>>3,S=(0,e.rotr)(l,17)^(0,e.rotr)(l,19)^l>>>10;o[_]=S+o[_-7]+p+o[_-16]|0}let{A:m,B:g,C:x,D:u,E:d,F:y,G:w,H:B}=this;for(let _=0;_<64;_++){const H=(0,e.rotr)(d,6)^(0,e.rotr)(d,11)^(0,e.rotr)(d,25),l=B+H+n(d,y,w)+s[_]+o[_]|0,S=((0,e.rotr)(m,2)^(0,e.rotr)(m,13)^(0,e.rotr)(m,22))+r(m,g,x)|0;B=w,w=y,y=d,d=u+l|0,u=x,x=g,g=m,m=l+S|0}m=m+this.A|0,g=g+this.B|0,x=x+this.C|0,u=u+this.D|0,d=d+this.E|0,y=y+this.F|0,w=w+this.G|0,B=B+this.H|0,this.set(m,g,x,u,d,y,w,B)}roundClean(){o.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class f extends c{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}return wt.sha256=(0,e.wrapConstructor)(()=>new c),wt.sha224=(0,e.wrapConstructor)(()=>new f),wt}var Ve;function ys(){if(Ve)return yt;Ve=1,Object.defineProperty(yt,"__esModule",{value:!0}),yt.scryptAsync=yt.scrypt=void 0;const t=Qt(),e=fs(),n=cs(),r=Ht(),s=(a,m)=>a<<m|a>>>32-m;function i(a,m,g,x,u,d){let y=a[m++]^g[x++],w=a[m++]^g[x++],B=a[m++]^g[x++],_=a[m++]^g[x++],H=a[m++]^g[x++],l=a[m++]^g[x++],p=a[m++]^g[x++],S=a[m++]^g[x++],E=a[m++]^g[x++],A=a[m++]^g[x++],L=a[m++]^g[x++],k=a[m++]^g[x++],T=a[m++]^g[x++],C=a[m++]^g[x++],I=a[m++]^g[x++],v=a[m++]^g[x++],O=y,N=w,q=B,$=_,R=H,j=l,M=p,D=S,W=E,K=A,z=L,ot=k,Q=T,F=C,ct=I,tt=v;for(let et=0;et<8;et+=2)R^=s(O+Q|0,7),W^=s(R+O|0,9),Q^=s(W+R|0,13),O^=s(Q+W|0,18),K^=s(j+N|0,7),F^=s(K+j|0,9),N^=s(F+K|0,13),j^=s(N+F|0,18),ct^=s(z+M|0,7),q^=s(ct+z|0,9),M^=s(q+ct|0,13),z^=s(M+q|0,18),$^=s(tt+ot|0,7),D^=s($+tt|0,9),ot^=s(D+$|0,13),tt^=s(ot+D|0,18),N^=s(O+$|0,7),q^=s(N+O|0,9),$^=s(q+N|0,13),O^=s($+q|0,18),M^=s(j+R|0,7),D^=s(M+j|0,9),R^=s(D+M|0,13),j^=s(R+D|0,18),ot^=s(z+K|0,7),W^=s(ot+z|0,9),K^=s(W+ot|0,13),z^=s(K+W|0,18),Q^=s(tt+ct|0,7),F^=s(Q+tt|0,9),ct^=s(F+Q|0,13),tt^=s(ct+F|0,18);u[d++]=y+O|0,u[d++]=w+N|0,u[d++]=B+q|0,u[d++]=_+$|0,u[d++]=H+R|0,u[d++]=l+j|0,u[d++]=p+M|0,u[d++]=S+D|0,u[d++]=E+W|0,u[d++]=A+K|0,u[d++]=L+z|0,u[d++]=k+ot|0,u[d++]=T+Q|0,u[d++]=C+F|0,u[d++]=I+ct|0,u[d++]=v+tt|0}function o(a,m,g,x,u){let d=x+0,y=x+16*u;for(let w=0;w<16;w++)g[y+w]=a[m+(2*u-1)*16+w];for(let w=0;w<u;w++,d+=16,m+=16)i(g,y,a,m,g,d),w>0&&(y+=16),i(g,d,a,m+=16,g,y)}function c(a,m,g){const x=(0,r.checkOpts)({dkLen:32,asyncTick:10,maxmem:1073742848},g),{N:u,r:d,p:y,dkLen:w,asyncTick:B,maxmem:_,onProgress:H}=x;if((0,t.number)(u),(0,t.number)(d),(0,t.number)(y),(0,t.number)(w),(0,t.number)(B),(0,t.number)(_),H!==void 0&&typeof H!="function")throw new Error("progressCb should be function");const l=128*d,p=l/4;if(u<=1||u&u-1||u>=2**(l/8)||u>2**32)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(y<0||y>(2**32-1)*32/l)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(w<0||w>(2**32-1)*32)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const S=l*(u+y);if(S>_)throw new Error(`Scrypt: parameters too large, ${S} (128 * r * (N + p)) > ${_} (maxmem)`);const E=(0,n.pbkdf2)(e.sha256,a,m,{c:1,dkLen:l*y}),A=(0,r.u32)(E),L=(0,r.u32)(new Uint8Array(l*u)),k=(0,r.u32)(new Uint8Array(l));let T=()=>{};if(H){const C=2*u*y,I=Math.max(Math.floor(C/1e4),1);let v=0;T=()=>{v++,H&&(!(v%I)||v===C)&&H(v/C)}}return{N:u,r:d,p:y,dkLen:w,blockSize32:p,V:L,B32:A,B:E,tmp:k,blockMixCb:T,asyncTick:B}}function f(a,m,g,x,u){const d=(0,n.pbkdf2)(e.sha256,a,g,{c:1,dkLen:m});return g.fill(0),x.fill(0),u.fill(0),d}function h(a,m,g){const{N:x,r:u,p:d,dkLen:y,blockSize32:w,V:B,B32:_,B:H,tmp:l,blockMixCb:p}=c(a,m,g);for(let S=0;S<d;S++){const E=w*S;for(let A=0;A<w;A++)B[A]=_[E+A];for(let A=0,L=0;A<x-1;A++)o(B,L,B,L+=w,u),p();o(B,(x-1)*w,_,E,u),p();for(let A=0;A<x;A++){const L=_[E+w-16]%x;for(let k=0;k<w;k++)l[k]=_[E+k]^B[L*w+k];o(l,0,_,E,u),p()}}return f(a,y,H,B,l)}yt.scrypt=h;async function b(a,m,g){const{N:x,r:u,p:d,dkLen:y,blockSize32:w,V:B,B32:_,B:H,tmp:l,blockMixCb:p,asyncTick:S}=c(a,m,g);for(let E=0;E<d;E++){const A=w*E;for(let k=0;k<w;k++)B[k]=_[A+k];let L=0;await(0,r.asyncLoop)(x-1,S,()=>{o(B,L,B,L+=w,u),p()}),o(B,(x-1)*w,_,A,u),p(),await(0,r.asyncLoop)(x,S,()=>{const k=_[A+w-16]%x;for(let T=0;T<w;T++)l[T]=_[A+T]^B[k*w+T];o(l,0,_,A,u),p()})}return f(a,y,H,B,l)}return yt.scryptAsync=b,yt}const ws=St(ss);export{bs as a,hs as b,ds as c,xs as d,gs as e,ys as f,ws as g,br as h,Gn as k,cs as r};
