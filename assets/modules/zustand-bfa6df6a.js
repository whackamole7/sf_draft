const E=o=>(t,i,r)=>{const l=r.subscribe;return r.subscribe=(v,d,u)=>{let c=v;if(d){const m=(u==null?void 0:u.equalityFn)||Object.is;let h=v(r.getState());c=g=>{const S=v(g);if(!m(h,S)){const p=h;d(h=S,p)}},u!=null&&u.fireImmediately&&d(h,h)}return l(c)},o(t,i,r)},H=E;function w(o,t){let i;try{i=o()}catch{return}return{getItem:l=>{var e;const v=u=>u===null?null:JSON.parse(u,t==null?void 0:t.reviver),d=(e=i.getItem(l))!=null?e:null;return d instanceof Promise?d.then(v):v(d)},setItem:(l,e)=>i.setItem(l,JSON.stringify(e,t==null?void 0:t.replacer)),removeItem:l=>i.removeItem(l)}}const b=o=>t=>{try{const i=o(t);return i instanceof Promise?i:{then(r){return b(r)(i)},catch(r){return this}}}catch(i){return{then(r){return this},catch(r){return b(r)(i)}}}},O=(o,t)=>(i,r,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:s=>s,version:0,merge:(s,f)=>({...f,...s}),...t},v=!1;const d=new Set,u=new Set;let c;try{c=e.getStorage()}catch{}if(!c)return o((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...s)},r,l);const m=b(e.serialize),h=()=>{const s=e.partialize({...r()});let f;const n=m({state:s,version:e.version}).then(y=>c.setItem(e.name,y)).catch(y=>{f=y});if(f)throw f;return n},g=l.setState;l.setState=(s,f)=>{g(s,f),h()};const S=o((...s)=>{i(...s),h()},r,l);let p;const a=()=>{var s;if(!c)return;v=!1,d.forEach(n=>n(r()));const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,r()))||void 0;return b(c.getItem.bind(c))(e.name).then(n=>{if(n)return e.deserialize(n)}).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var y;return p=e.merge(n,(y=r())!=null?y:S),i(p,!0),h()}).then(()=>{f==null||f(p,void 0),v=!0,u.forEach(n=>n(p))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:s=>{e={...e,...s},s.getStorage&&(c=s.getStorage())},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>a(),hasHydrated:()=>v,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(u.add(s),()=>{u.delete(s)})},a(),p||S},R=(o,t)=>(i,r,l)=>{let e={storage:w(()=>localStorage),partialize:a=>a,version:0,merge:(a,s)=>({...s,...a}),...t},v=!1;const d=new Set,u=new Set;let c=e.storage;if(!c)return o((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...a)},r,l);const m=()=>{const a=e.partialize({...r()});return c.setItem(e.name,{state:a,version:e.version})},h=l.setState;l.setState=(a,s)=>{h(a,s),m()};const g=o((...a)=>{i(...a),m()},r,l);let S;const p=()=>{var a,s;if(!c)return;v=!1,d.forEach(n=>{var y;return n((y=r())!=null?y:g)});const f=((s=e.onRehydrateStorage)==null?void 0:s.call(e,(a=r())!=null?a:g))||void 0;return b(c.getItem.bind(c))(e.name).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==e.version){if(e.migrate)return e.migrate(n.state,n.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return n.state}).then(n=>{var y;return S=e.merge(n,(y=r())!=null?y:g),i(S,!0),m()}).then(()=>{f==null||f(S,void 0),S=r(),v=!0,u.forEach(n=>n(S))}).catch(n=>{f==null||f(void 0,n)})};return l.persist={setOptions:a=>{e={...e,...a},a.storage&&(c=a.storage)},clearStorage:()=>{c==null||c.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>p(),hasHydrated:()=>v,onHydrate:a=>(d.add(a),()=>{d.delete(a)}),onFinishHydration:a=>(u.add(a),()=>{u.delete(a)})},e.skipHydration||p(),S||g},_=(o,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?O(o,t):R(o,t),D=_,I=o=>{let t;const i=new Set,r=(u,c)=>{const m=typeof u=="function"?u(t):u;if(!Object.is(m,t)){const h=t;t=c??typeof m!="object"?m:Object.assign({},t,m),i.forEach(g=>g(t,h))}},l=()=>t,d={setState:r,getState:l,subscribe:u=>(i.add(u),()=>i.delete(u)),destroy:()=>{i.clear()}};return t=o(r,l,d),d},z=o=>o?I(o):I;function k(o,t){if(Object.is(o,t))return!0;if(typeof o!="object"||o===null||typeof t!="object"||t===null)return!1;if(o instanceof Map&&t instanceof Map){if(o.size!==t.size)return!1;for(const[r,l]of o)if(!Object.is(l,t.get(r)))return!1;return!0}if(o instanceof Set&&t instanceof Set){if(o.size!==t.size)return!1;for(const r of o)if(!t.has(r))return!1;return!0}const i=Object.keys(o);if(i.length!==Object.keys(t).length)return!1;for(let r=0;r<i.length;r++)if(!Object.prototype.hasOwnProperty.call(t,i[r])||!Object.is(o[i[r]],t[i[r]]))return!1;return!0}export{H as a,z as c,D as p,k as s};
